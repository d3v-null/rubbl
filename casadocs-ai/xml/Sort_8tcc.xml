<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="Sort_8tcc" kind="file" language="C++">
    <compoundname>Sort.tcc</compoundname>
    <includedby refid="Sort_8cc" local="no">casa/Utilities/Sort.cc</includedby>
    <invincdepgraph>
      <node id="1">
        <label>casa/Utilities/Sort.tcc</label>
        <link refid="Sort_8tcc"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>casa/Utilities/Sort.cc</label>
        <link refid="Sort_8cc"/>
      </node>
    </invincdepgraph>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">//#<sp/>Sort.tcc:<sp/>Sort<sp/>objects<sp/>on<sp/>one<sp/>or<sp/>more<sp/>keys</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Copyright<sp/>(C)<sp/>1995,1996,1997,1998,1999,2000,2001</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Associated<sp/>Universities,<sp/>Inc.<sp/>Washington<sp/>DC,<sp/>USA.</highlight></codeline>
<codeline><highlight class="normal">//#</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>This<sp/>library<sp/>is<sp/>free<sp/>software;<sp/>you<sp/>can<sp/>redistribute<sp/>it<sp/>and/or<sp/>modify<sp/>it</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>under<sp/>the<sp/>terms<sp/>of<sp/>the<sp/>GNU<sp/>Library<sp/>General<sp/>Public<sp/>License<sp/>as<sp/>published<sp/>by</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>the<sp/>Free<sp/>Software<sp/>Foundation;<sp/>either<sp/>version<sp/>2<sp/>of<sp/>the<sp/>License,<sp/>or<sp/>(at<sp/>your</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>option)<sp/>any<sp/>later<sp/>version.</highlight></codeline>
<codeline><highlight class="normal">//#</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>This<sp/>library<sp/>is<sp/>distributed<sp/>in<sp/>the<sp/>hope<sp/>that<sp/>it<sp/>will<sp/>be<sp/>useful,<sp/>but<sp/>WITHOUT</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>ANY<sp/>WARRANTY;<sp/>without<sp/>even<sp/>the<sp/>implied<sp/>warranty<sp/>of<sp/>MERCHANTABILITY<sp/>or</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE.<sp/><sp/>See<sp/>the<sp/>GNU<sp/>Library<sp/>General<sp/>Public</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>License<sp/>for<sp/>more<sp/>details.</highlight></codeline>
<codeline><highlight class="normal">//#</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>You<sp/>should<sp/>have<sp/>received<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>GNU<sp/>Library<sp/>General<sp/>Public<sp/>License</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>along<sp/>with<sp/>this<sp/>library;<sp/>if<sp/>not,<sp/>write<sp/>to<sp/>the<sp/>Free<sp/>Software<sp/>Foundation,</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Inc.,<sp/>675<sp/>Massachusetts<sp/>Ave,<sp/>Cambridge,<sp/>MA<sp/>02139,<sp/>USA.</highlight></codeline>
<codeline><highlight class="normal">//#</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Correspondence<sp/>concerning<sp/>AIPS++<sp/>should<sp/>be<sp/>addressed<sp/>as<sp/>follows:</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Internet<sp/>email:<sp/>casa-feedback@nrao.edu.</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Postal<sp/>address:<sp/>AIPS++<sp/>Project<sp/>Office</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>National<sp/>Radio<sp/>Astronomy<sp/>Observatory</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>520<sp/>Edgemont<sp/>Road</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Charlottesville,<sp/>VA<sp/>22903-2475<sp/>USA</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>CASA_SORT_TCC</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>CASA_SORT_TCC</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//#<sp/>Includes</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;casacore/casa/Utilities/Sort.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;casacore/casa/Utilities/SortError.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;casacore/casa/Arrays/ArrayMath.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;omp.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">namespace<sp/>casacore<sp/>{<sp/>//#<sp/>NAMESPACE<sp/>CASACORE<sp/>-<sp/>BEGIN</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>Sort::doSort<sp/>(Vector&lt;T&gt;&amp;<sp/>indexVector,<sp/>T<sp/>nrrec,<sp/>int<sp/>opt,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bool<sp/>doTryGenSort)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nrrec<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>nrrec;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//#<sp/>Try<sp/>if<sp/>we<sp/>can<sp/>use<sp/>the<sp/>faster<sp/>GenSort<sp/>when<sp/>we<sp/>have<sp/>one<sp/>key<sp/>only.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(doTryGenSort<sp/><sp/>&amp;&amp;<sp/><sp/>nrkey_p<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>uInt<sp/>n<sp/>=<sp/>keys_p[0]-&gt;tryGenSort<sp/>(indexVector,<sp/>nrrec,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>indexVector.resize<sp/>(nrrec);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>indgen<sp/>(indexVector);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Pass<sp/>the<sp/>sort<sp/>function<sp/>a<sp/>C-array<sp/>of<sp/>indices,<sp/>because<sp/>indexing</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>in<sp/>there<sp/>is<sp/>(much)<sp/>faster<sp/>than<sp/>in<sp/>a<sp/>vector.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Bool<sp/>del;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>inx<sp/>=<sp/>indexVector.getStorage<sp/>(del);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Choose<sp/>the<sp/>sort<sp/>required.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>nodup<sp/>=<sp/>opt<sp/>&amp;<sp/>NoDuplicates;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>type<sp/><sp/>=<sp/>opt<sp/>-<sp/>nodup;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Determine<sp/>default<sp/>sort<sp/>to<sp/>use.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>nthr<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nthr<sp/>=<sp/>omp_get_max_threads();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Do<sp/>not<sp/>use<sp/>more<sp/>threads<sp/>than<sp/>there<sp/>are<sp/>values.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(uInt(nthr)<sp/>&gt;<sp/>nrrec)<sp/>nthr<sp/>=<sp/>nrrec;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(type<sp/>==<sp/>DefaultSort)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>(nrrec&lt;1000<sp/>||<sp/>nthr==1<sp/><sp/>?<sp/><sp/>QuickSort<sp/>:<sp/>ParSort);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>n<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>switch<sp/>(type)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>QuickSort:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(nodup)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>quickSortNoDup<sp/>(nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}else{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>quickSort<sp/>(nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>HeapSort:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(nodup)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>heapSortNoDup<sp/>(nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}else{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>heapSort<sp/>(nrrec,inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>InsSort:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(nodup)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>insSortNoDup<sp/>(nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}else{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>insSort<sp/>(nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>ParSort:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>parSort<sp/>(nthr,<sp/>nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(nodup)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>insSortNoDup<sp/>(nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>default:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>SortInvOpt();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>indexVector.putStorage<sp/>(inx,<sp/>del);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>If<sp/>n<sp/>&lt;<sp/>nrrec,<sp/>some<sp/>duplicates<sp/>have<sp/>been<sp/>deleted.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>This<sp/>means<sp/>we<sp/>have<sp/>to<sp/>resize<sp/>the<sp/>Vector.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&lt;<sp/>nrrec)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>indexVector.resize<sp/>(n,<sp/>True);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>Sort::doUnique<sp/>(Vector&lt;T&gt;&amp;<sp/>uniqueVector,<sp/>T<sp/>nrrec)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vector&lt;T&gt;<sp/>indexVector(nrrec);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>indgen<sp/>(indexVector);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>doUnique<sp/>(uniqueVector,<sp/>indexVector);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>Sort::doUnique<sp/>(Vector&lt;T&gt;&amp;<sp/>uniqueVector,<sp/>const<sp/>Vector&lt;T&gt;&amp;<sp/>indexVector)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vector&lt;size_t&gt;<sp/>changeKey;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>doUnique<sp/>(uniqueVector,<sp/>changeKey,<sp/>indexVector);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>Sort::doUnique<sp/>(Vector&lt;T&gt;&amp;<sp/>uniqueVector,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector&lt;size_t&gt;&amp;<sp/>changeKey,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Vector&lt;T&gt;&amp;<sp/>indexVector)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>nrrec<sp/>=<sp/>indexVector.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uniqueVector.resize<sp/>(nrrec);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>changeKey.resize<sp/>(nrrec);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nrrec<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Pass<sp/>the<sp/>sort<sp/>function<sp/>a<sp/>C-array<sp/>of<sp/>indices,<sp/>because<sp/>indexing</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>in<sp/>there<sp/>is<sp/>(much)<sp/>faster<sp/>than<sp/>in<sp/>a<sp/>vector.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Bool<sp/>delInx,<sp/>delUniq,<sp/>delChange;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>T*<sp/>inx<sp/>=<sp/>indexVector.getStorage<sp/>(delInx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>uniq<sp/>=<sp/>uniqueVector.getStorage<sp/>(delUniq);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t*<sp/>change<sp/>=<sp/>changeKey.getStorage<sp/>(delChange);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uniq[0]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>nruniq<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>idxComp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(T<sp/>i=1;<sp/>i&lt;nrrec;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Int<sp/>cmp<sp/>=<sp/>compareChangeIdx<sp/>(inx[i-1],<sp/>inx[i],<sp/>idxComp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(cmp<sp/>!=<sp/>1<sp/><sp/>&amp;&amp;<sp/><sp/>cmp<sp/>!=<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>change[nruniq-1]<sp/>=<sp/>idxComp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniq[nruniq++]<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>indexVector.freeStorage<sp/>(inx,<sp/>delInx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uniqueVector.putStorage<sp/>(uniq,<sp/>delUniq);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>changeKey.putStorage<sp/>(change,<sp/>delChange);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nruniq<sp/>&lt;<sp/>nrrec)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>uniqueVector.resize<sp/>(nruniq,<sp/>True);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>changeKey.resize<sp/>(nruniq,<sp/>True);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>nruniq;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>Sort::parSort<sp/>(int<sp/>nthr,<sp/>T<sp/>nrrec,<sp/>T*<sp/>inx)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Block&lt;T&gt;<sp/>index(nrrec+1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Block&lt;T&gt;<sp/>tinx(nthr+1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Block&lt;T&gt;<sp/>np(nthr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Determine<sp/>ordered<sp/>parts<sp/>in<sp/>the<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>It<sp/>is<sp/>done<sp/>in<sp/>parallel,<sp/>whereafter<sp/>the<sp/>parts<sp/>are<sp/>combined.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>step<sp/>=<sp/>nrrec/nthr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;nthr;<sp/>++i)<sp/>tinx[i]<sp/>=<sp/>i*step;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tinx[nthr]<sp/>=<sp/>nrrec;</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;nthr;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>nparts<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>index[tinx[i]]<sp/>=<sp/>tinx[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(T<sp/>j=tinx[i]+1;<sp/>j&lt;tinx[i+1];<sp/>++j)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(compare<sp/>(inx[j-1],<sp/>inx[j])<sp/>&lt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index[tinx[i]+nparts]<sp/>=<sp/>j;<sp/><sp/><sp/><sp/>//<sp/>out<sp/>of<sp/>order,<sp/>thus<sp/>new<sp/>part</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nparts++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>np[i]<sp/>=<sp/>nparts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Make<sp/>index<sp/>parts<sp/>consecutive<sp/>by<sp/>shifting<sp/>to<sp/>the<sp/>left.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>See<sp/>if<sp/>last<sp/>and<sp/>next<sp/>part<sp/>can<sp/>be<sp/>combined.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>nparts<sp/>=<sp/>np[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i=1;<sp/>i&lt;nthr;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(compare<sp/>(tinx[i]-1,<sp/>tinx[i])<sp/>&lt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index[nparts++]<sp/>=<sp/>index[tinx[i]];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(nparts<sp/>==<sp/>tinx[i]+1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nparts<sp/>+=<sp/>np[i]-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(T<sp/>j=1;<sp/>j&lt;np[i];<sp/>++j)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index[nparts++]<sp/>=<sp/>index[tinx[i]+j];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>index[nparts]<sp/>=<sp/>nrrec;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//cout&lt;&lt;&quot;nparts=&quot;&lt;&lt;nparts&lt;&lt;endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Merge<sp/>the<sp/>array<sp/>parts.<sp/>Each<sp/>part<sp/>is<sp/>ordered.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nparts<sp/>&lt;<sp/>nrrec)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Block&lt;T&gt;<sp/>inxtmp(nrrec);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>merge<sp/>(inx,<sp/>inxtmp.storage(),<sp/>nrrec,<sp/>index.storage(),<sp/>nparts);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Each<sp/>part<sp/>has<sp/>length<sp/>1,<sp/>so<sp/>the<sp/>array<sp/>is<sp/>in<sp/>reversed<sp/>order.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(T<sp/>i=0;<sp/>i&lt;nrrec;<sp/>++i)<sp/>inx[i]<sp/>=<sp/>nrrec-1-i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>nrrec;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/><sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Sort::merge<sp/>(T*<sp/>inx,<sp/>T*<sp/>tmp,<sp/>T<sp/>nrrec,<sp/>T*<sp/>index,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>nparts)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>a<sp/>=<sp/>inx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>b<sp/>=<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>np<sp/>=<sp/>nparts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>If<sp/>the<sp/>nr<sp/>of<sp/>parts<sp/>is<sp/>odd,<sp/>the<sp/>last<sp/>part<sp/>is<sp/>not<sp/>merged.<sp/>To<sp/>avoid<sp/>having</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>to<sp/>copy<sp/>it<sp/>to<sp/>the<sp/>other<sp/>array,<sp/>a<sp/>pointer<sp/>&apos;last&apos;<sp/>is<sp/>kept.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Note<sp/>that<sp/>merging<sp/>the<sp/>previous<sp/>part<sp/>with<sp/>the<sp/>last<sp/>part<sp/>works<sp/>fine,<sp/>even</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>if<sp/>the<sp/>last<sp/>part<sp/>is<sp/>in<sp/>the<sp/>same<sp/>buffer.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>last<sp/>=<sp/>inx<sp/>+<sp/>index[np-1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(np<sp/>&gt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>omp<sp/>parallel<sp/>for<sp/>schedule(dynamic)</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;np;<sp/>i+=2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>&lt;<sp/>np-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Merge<sp/>2<sp/>subsequent<sp/>parts<sp/>of<sp/>the<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T*<sp/>f1<sp/>=<sp/>a+index[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T*<sp/>f2<sp/>=<sp/>a+index[i+1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T*<sp/>to<sp/>=<sp/>b+index[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>na<sp/>=<sp/>index[i+1]-index[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>nb<sp/>=<sp/>index[i+2]-index[i+1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>np-2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//cout&lt;&lt;&quot;swap<sp/>last<sp/>np=&quot;<sp/>&lt;&lt;np&lt;&lt;endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>f2<sp/>=<sp/>last;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>last<sp/>=<sp/>to;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>ia=0,<sp/>ib=0,<sp/>k=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(ia<sp/>&lt;<sp/>na<sp/>&amp;&amp;<sp/>ib<sp/>&lt;<sp/>nb)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(compare(f1[ia],<sp/>f2[ib])<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to[k]<sp/>=<sp/>f1[ia++];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to[k]<sp/>=<sp/>f2[ib++];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>k++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(ia<sp/>&lt;<sp/>na)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(T<sp/>p=ia;<sp/>p&lt;na;<sp/>p++,k++)<sp/>to[k]<sp/>=<sp/>f1[p];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(T<sp/>p=ib;<sp/>p&lt;nb;<sp/>p++,k++)<sp/>to[k]<sp/>=<sp/>f2[p];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Collapse<sp/>the<sp/>index.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>k=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;np;<sp/>i+=2)<sp/>index[k++]<sp/>=<sp/>index[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>index[k]<sp/>=<sp/>nrrec;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>np<sp/>=<sp/>k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Swap<sp/>the<sp/>index<sp/>target<sp/>and<sp/>destination.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T*<sp/>c<sp/>=<sp/>a;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>a<sp/>=<sp/>b;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>b<sp/>=<sp/>c;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>If<sp/>final<sp/>result<sp/>happens<sp/>to<sp/>be<sp/>in<sp/>incorrect<sp/>array,<sp/>copy<sp/>it<sp/>over.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(a<sp/>!=<sp/>inx)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>objcopy<sp/>(inx,<sp/>a,<sp/>nrrec);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>Sort::insSort<sp/>(T<sp/>nrrec,<sp/>T*<sp/>inx)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(T<sp/>i=1;<sp/>i&lt;nrrec;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Int64<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>cur<sp/>=<sp/>inx[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(--j&gt;=0<sp/><sp/>&amp;&amp;<sp/><sp/>compare(inx[j],<sp/>cur)<sp/>&lt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inx[j+1]<sp/>=<sp/>inx[j];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>inx[j+1]<sp/>=<sp/>cur;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>nrrec;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>Sort::insSortNoDup<sp/>(T<sp/>nrrec,<sp/>T*<sp/>inx)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nrrec<sp/>&lt;<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>nrrec;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>nothing<sp/>to<sp/>sort</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>nr<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>cmp<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(T<sp/>i=1;<sp/>i&lt;nrrec;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Int64<sp/>j<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>cur<sp/>=<sp/>inx[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Continue<sp/>as<sp/>long<sp/>as<sp/>key<sp/>is<sp/>out<sp/>of<sp/>order.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(--j&gt;=0<sp/><sp/>&amp;&amp;<sp/><sp/>(cmp<sp/>=<sp/>compare<sp/>(inx[j],<sp/>cur))<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(j&lt;0<sp/>||<sp/>cmp==2)<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>no<sp/>equal<sp/>key</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(Int64<sp/>k=nr-1;<sp/>k&gt;j;<sp/>k--)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inx[k+1]<sp/>=<sp/>inx[k];<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>now<sp/>shift<sp/>to<sp/>right</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inx[j+1]<sp/>=<sp/>cur;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>insert<sp/>in<sp/>right<sp/>place</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nr++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>Sort::quickSort<sp/>(T<sp/>nrrec,<sp/>T*<sp/>inx)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Use<sp/>the<sp/>quicksort<sp/>algorithm<sp/>and<sp/>improvements<sp/>as<sp/>described</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>in<sp/>&quot;Algorithms<sp/>in<sp/>C&quot;<sp/>by<sp/>R.<sp/>Sedgewick.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Small<sp/>subsets<sp/>are<sp/>not<sp/>sorted<sp/>with<sp/>qksort<sp/>anymore,<sp/>but</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>thereafter<sp/>with<sp/>insertion<sp/>sort.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>qkSort<sp/>(nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>insSort<sp/>(nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>Sort::quickSortNoDup<sp/>(T<sp/>nrrec,<sp/>T*<sp/>inx)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>qkSort<sp/>(nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>insSortNoDup<sp/>(nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Sort::qkSort<sp/>(T<sp/>nr,<sp/>T*<sp/>inx)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>If<sp/>the<sp/>nr<sp/>of<sp/>elements<sp/>to<sp/>be<sp/>sorted<sp/>is<sp/>less<sp/>than<sp/>N,<sp/>it<sp/>is</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>better<sp/>not<sp/>to<sp/>use<sp/>quicksort<sp/>anymore<sp/>(according<sp/>to<sp/>Sedgewick).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Take<sp/>N=15,<sp/>because<sp/>that<sp/>seems<sp/>to<sp/>work<sp/>best<sp/>after<sp/>testing</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>N=5,<sp/>10,<sp/>15<sp/>and<sp/>20.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nr<sp/>&lt;=<sp/>15)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>According<sp/>to<sp/>Sedgewick<sp/>it<sp/>is<sp/>best<sp/>to<sp/>use<sp/>a<sp/>random<sp/>partition<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>to<sp/>avoid<sp/>degenerated<sp/>cases<sp/>(if<sp/>the<sp/>data<sp/>is<sp/>already<sp/>in<sp/>order<sp/>for<sp/>example)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>rand<sp/>is<sp/>not<sp/>a<sp/>particularly<sp/>good<sp/>random<sp/>number<sp/>generator,<sp/>but<sp/>good</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>enough<sp/>for<sp/>this<sp/>purpose.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Put<sp/>this<sp/>element<sp/>at<sp/>the<sp/>beginning<sp/>of<sp/>the<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>p<sp/>=<sp/>rand()<sp/>%<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>swap<sp/>(T(0),<sp/>p,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Now<sp/>shift<sp/>all<sp/>elements<sp/>&lt;<sp/>partition-element<sp/>to<sp/>the<sp/>left.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>If<sp/>an<sp/>element<sp/>is<sp/>equal,<sp/>shift<sp/>every<sp/>other<sp/>element<sp/>to<sp/>avoid</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>degeneration.<sp/>This<sp/>trick<sp/>is<sp/>described<sp/>by<sp/>Jon<sp/>Bentley<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>UNIX<sp/>Review,<sp/>October<sp/>1992.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>We<sp/>do<sp/>not<sp/>have<sp/>equal<sp/>elements<sp/>anymore<sp/>(because<sp/>of<sp/>the<sp/>stability</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>property<sp/>introduced<sp/>on<sp/>13-Feb-1995).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>j<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(T<sp/>i=1;<sp/>i&lt;nr;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(compare<sp/>(inx[0],<sp/>inx[i])<sp/>&lt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>swap<sp/>(i,<sp/>++j,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>swap<sp/>(T(0),<sp/>j,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>qkSort<sp/>(j,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>qkSort<sp/>(nr-j-1,<sp/>inx+j+1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>Sort::heapSort<sp/>(T<sp/>nrrec,<sp/>T*<sp/>inx)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Use<sp/>the<sp/>heapsort<sp/>algorithm<sp/>described<sp/>by<sp/>Jon<sp/>Bentley<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>UNIX<sp/>Review,<sp/>August<sp/>1992.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inx--;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(j=nrrec/2;<sp/>j&gt;=1;<sp/>j--)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>siftDown<sp/>(j,<sp/>nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(j=nrrec;<sp/>j&gt;=2;<sp/>j--)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>swap<sp/>(T(1),<sp/>j,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>siftDown<sp/>(T(1),<sp/>j-1,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>nrrec;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>Sort::heapSortNoDup<sp/>(T<sp/>nrrec,<sp/>T*<sp/>inx)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>heapSort<sp/>(nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>insSortNoDup<sp/>(nrrec,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Sort::siftDown<sp/>(T<sp/>low,<sp/>T<sp/>up,<sp/>T*<sp/>inx)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>sav<sp/>=<sp/>inx[low];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>c;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(i=low;<sp/>(c=2*i)&lt;=up;<sp/>i=c)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(c<sp/>&lt;<sp/>up<sp/><sp/>&amp;&amp;<sp/><sp/>compare(inx[c+1],<sp/>inx[c])<sp/>&lt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>inx[i]<sp/>=<sp/>inx[c];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inx[i]<sp/>=<sp/>sav;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(<sp/>;<sp/>(c=i/2)&gt;=low;<sp/>i=c)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(compare<sp/>(inx[i],<sp/>inx[c])<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>swap<sp/>(c,<sp/>i,<sp/>inx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Note<sp/>that<sp/>the<sp/>block<sp/>of<sp/>SortKeys<sp/>is<sp/>defined<sp/>as<sp/>void*,<sp/>to<sp/>achieve</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>that<sp/>only<sp/>1<sp/>type<sp/>of<sp/>Block&lt;pointer&gt;<sp/>is<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Casting<sp/>is<sp/>perfectly<sp/>save.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>comparison<sp/>functions<sp/>return:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/>-1<sp/><sp/><sp/>when<sp/>obj1<sp/>&lt;<sp/>obj2</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/><sp/>0<sp/><sp/><sp/>when<sp/>obj1<sp/>=<sp/>obj2</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/><sp/>1<sp/><sp/><sp/>when<sp/>obj1<sp/>&gt;<sp/>obj2</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>compare<sp/>returns:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/><sp/>2<sp/><sp/><sp/>when<sp/>data[i1],data[i2]<sp/>is<sp/>in<sp/>correct<sp/>order</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(thus<sp/>data[i1]<sp/>&lt;<sp/>data[i2]<sp/>for<sp/>ascending<sp/>sort)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/><sp/>1<sp/><sp/><sp/>when<sp/>data<sp/>is<sp/>equal<sp/>and<sp/>indices<sp/>are<sp/>in<sp/>order</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/><sp/>0<sp/><sp/><sp/>when<sp/>data<sp/>is<sp/>out<sp/>of<sp/>order</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/>-1<sp/><sp/><sp/>when<sp/>data<sp/>is<sp/>equal<sp/>and<sp/>indices<sp/>are<sp/>out<sp/>of<sp/>order</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>Sort::compare<sp/>(T<sp/>i1,<sp/>T<sp/>i2)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>idxComp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>compareChangeIdx(i1,<sp/>i2,<sp/>idxComp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>This<sp/>is<sp/>a<sp/>similar<sp/>function<sp/>to<sp/>compare()<sp/>but<sp/>it<sp/>also<sp/>gives<sp/>back<sp/>which<sp/>is<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>first<sp/>comparison<sp/>function<sp/>that<sp/>doesn&apos;t<sp/>match.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>idxComp<sp/>gives<sp/>the<sp/>comparison<sp/>function<sp/>index.<sp/>In<sp/>case<sp/>the<sp/>function<sp/>returns</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>1<sp/>or<sp/>-1<sp/>idxComp<sp/>is<sp/>not<sp/>modified.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>Sort::compareChangeIdx(T<sp/>i1,<sp/>T<sp/>i2,<sp/>size_t&amp;<sp/>idxComp)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>seq;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SortKey*<sp/>skp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;nrkey_p;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>skp<sp/>=<sp/>keys_p[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>seq<sp/>=<sp/>skp-&gt;cmpObj_p-&gt;comp<sp/>((char*)skp-&gt;data_p<sp/>+<sp/>i1*skp-&gt;incr_p,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(char*)skp-&gt;data_p<sp/>+<sp/>i2*skp-&gt;incr_p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(seq<sp/>==<sp/>skp-&gt;order_p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idxComp<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>2;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>in<sp/>order</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(seq<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idxComp<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>out-of-order</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Equal<sp/>keys,<sp/>so<sp/>return<sp/>i1&lt;i2<sp/>to<sp/>maintain<sp/>stability.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(i1&lt;i2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(order_p<sp/>==<sp/>1)<sp/>return<sp/>-1;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>desc,<sp/>thus<sp/>out-of-order</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>1;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>equal<sp/>keys;<sp/>in<sp/>order</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(order_p<sp/>==<sp/>1)<sp/>return<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>-1;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>equal<sp/>keys;<sp/>out-of-order</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">}<sp/>//#<sp/>NAMESPACE<sp/>CASACORE<sp/>-<sp/>END</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
    </programlisting>
    <location file="casa/Utilities/Sort.tcc"/>
  </compounddef>
</doxygen>
