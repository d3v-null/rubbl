<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="GenSort_8tcc" kind="file" language="C++">
    <compoundname>GenSort.tcc</compoundname>
    <includedby refid="GenSort_8h" local="no">casa/Utilities/GenSort.h</includedby>
    <invincdepgraph>
      <node id="9">
        <label>tables/DataMan/TiledStMan.cc</label>
        <link refid="TiledStMan_8cc"/>
      </node>
      <node id="1">
        <label>casa/Utilities/GenSort.tcc</label>
        <link refid="GenSort_8tcc"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="14">
        <label>tables/TaQL/ExprGroupAggrFuncArray.cc</label>
        <link refid="ExprGroupAggrFuncArray_8cc"/>
      </node>
      <node id="6">
        <label>casa/Utilities.h</label>
        <link refid="Utilities_8h"/>
      </node>
      <node id="16">
        <label>tables/TaQL/ExprNodeSetOpt.cc</label>
        <link refid="ExprNodeSetOpt_8cc"/>
      </node>
      <node id="2">
        <label>casa/Utilities/GenSort.h</label>
        <link refid="GenSort_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
      </node>
      <node id="18">
        <label>tables/TaQL/TaQLJoin.cc</label>
        <link refid="TaQLJoin_8cc"/>
      </node>
      <node id="13">
        <label>tables/TaQL/ExprGroupAggrFunc.cc</label>
        <link refid="ExprGroupAggrFunc_8cc"/>
      </node>
      <node id="4">
        <label>casa/Utilities/CompositeNumber.cc</label>
        <link refid="CompositeNumber_8cc"/>
      </node>
      <node id="5">
        <label>casa/Utilities/Sort.cc</label>
        <link refid="Sort_8cc"/>
      </node>
      <node id="7">
        <label>tables/apps/taql.cc</label>
        <link refid="taql_8cc"/>
      </node>
      <node id="17">
        <label>tables/TaQL/TableParseQuery.cc</label>
        <link refid="TableParseQuery_8cc"/>
      </node>
      <node id="12">
        <label>tables/Tables/ConcatColumn.cc</label>
        <link refid="ConcatColumn_8cc"/>
      </node>
      <node id="11">
        <label>tables/Tables/ColumnsIndexArray.cc</label>
        <link refid="ColumnsIndexArray_8cc"/>
      </node>
      <node id="8">
        <label>tables/DataMan/ISMBucket.cc</label>
        <link refid="ISMBucket_8cc"/>
      </node>
      <node id="15">
        <label>tables/TaQL/ExprNodeSetElem.cc</label>
        <link refid="ExprNodeSetElem_8cc"/>
      </node>
      <node id="3">
        <label>casa/IO/MultiFile.cc</label>
        <link refid="MultiFile_8cc"/>
      </node>
      <node id="10">
        <label>tables/Tables/BaseTable.cc</label>
        <link refid="BaseTable_8cc"/>
      </node>
    </invincdepgraph>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">//#<sp/>GenSort.cc:<sp/>General<sp/>sort<sp/>functions</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Copyright<sp/>(C)<sp/>1993,1994,1995,1996,1997,1998,1999,2000</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Associated<sp/>Universities,<sp/>Inc.<sp/>Washington<sp/>DC,<sp/>USA.</highlight></codeline>
<codeline><highlight class="normal">//#</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>This<sp/>library<sp/>is<sp/>free<sp/>software;<sp/>you<sp/>can<sp/>redistribute<sp/>it<sp/>and/or<sp/>modify<sp/>it</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>under<sp/>the<sp/>terms<sp/>of<sp/>the<sp/>GNU<sp/>Library<sp/>General<sp/>Public<sp/>License<sp/>as<sp/>published<sp/>by</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>the<sp/>Free<sp/>Software<sp/>Foundation;<sp/>either<sp/>version<sp/>2<sp/>of<sp/>the<sp/>License,<sp/>or<sp/>(at<sp/>your</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>option)<sp/>any<sp/>later<sp/>version.</highlight></codeline>
<codeline><highlight class="normal">//#</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>This<sp/>library<sp/>is<sp/>distributed<sp/>in<sp/>the<sp/>hope<sp/>that<sp/>it<sp/>will<sp/>be<sp/>useful,<sp/>but<sp/>WITHOUT</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>ANY<sp/>WARRANTY;<sp/>without<sp/>even<sp/>the<sp/>implied<sp/>warranty<sp/>of<sp/>MERCHANTABILITY<sp/>or</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE.<sp/><sp/>See<sp/>the<sp/>GNU<sp/>Library<sp/>General<sp/>Public</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>License<sp/>for<sp/>more<sp/>details.</highlight></codeline>
<codeline><highlight class="normal">//#</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>You<sp/>should<sp/>have<sp/>received<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>GNU<sp/>Library<sp/>General<sp/>Public<sp/>License</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>along<sp/>with<sp/>this<sp/>library;<sp/>if<sp/>not,<sp/>write<sp/>to<sp/>the<sp/>Free<sp/>Software<sp/>Foundation,</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Inc.,<sp/>675<sp/>Massachusetts<sp/>Ave,<sp/>Cambridge,<sp/>MA<sp/>02139,<sp/>USA.</highlight></codeline>
<codeline><highlight class="normal">//#</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Correspondence<sp/>concerning<sp/>AIPS++<sp/>should<sp/>be<sp/>addressed<sp/>as<sp/>follows:</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Internet<sp/>email:<sp/>casa-feedback@nrao.edu.</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Postal<sp/>address:<sp/>AIPS++<sp/>Project<sp/>Office</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>National<sp/>Radio<sp/>Astronomy<sp/>Observatory</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>520<sp/>Edgemont<sp/>Road</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Charlottesville,<sp/>VA<sp/>22903-2475<sp/>USA</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>CASA_GENSORT_TCC</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>CASA_GENSORT_TCC</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;casacore/casa/Utilities/GenSort.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;casacore/casa/Arrays/Array.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;casacore/casa/Arrays/Vector.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;casacore/casa/Arrays/ArrayMath.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;casacore/casa/Arrays/Slice.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;casacore/casa/BasicMath/Math.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;casacore/casa/Containers/Block.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;casacore/casa/Exceptions/Error.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal">#<sp/>include<sp/>&lt;omp.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">namespace<sp/>casacore<sp/>{<sp/>//#<sp/>NAMESPACE<sp/>CASACORE<sp/>-<sp/>BEGIN</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Do<sp/>a<sp/>quicksort<sp/>in<sp/>ascending<sp/>order.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>All<sp/>speedups<sp/>are<sp/>from<sp/>Sedgewick;<sp/>Algorithms<sp/>in<sp/>C.</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>GenSort&lt;T&gt;::quickSortAsc<sp/>(T*<sp/>data,<sp/>Int<sp/>nr,<sp/>Bool<sp/>multiThread,<sp/>Int<sp/>rec_lim)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>QuickSorting<sp/>small<sp/>sets<sp/>makes<sp/>no<sp/>sense.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>It<sp/>will<sp/>be<sp/>finished<sp/>with<sp/>an<sp/>insertion<sp/>sort.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>The<sp/>number<sp/>32<sp/>is<sp/>determined<sp/>experimentally.<sp/>It<sp/>is<sp/>not<sp/>very<sp/>critical.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nr<sp/>&lt;=<sp/>32)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>not<sp/>enough<sp/>progress,<sp/>abort<sp/>into<sp/>runtime<sp/>limited<sp/>heapsort</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(rec_lim<sp/>&lt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>heapSortAsc(data,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Choose<sp/>a<sp/>partition<sp/>element<sp/>by<sp/>taking<sp/>the<sp/>median<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>first,<sp/>middle<sp/>and<sp/>last<sp/>element.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Store<sp/>the<sp/>partition<sp/>element<sp/>at<sp/>the<sp/>end.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Do<sp/>not<sp/>use<sp/>Sedgewick\&apos;s<sp/>advise<sp/>to<sp/>store<sp/>the<sp/>partition<sp/>element<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>data[nr-2].<sp/>This<sp/>has<sp/>dramatic<sp/>results<sp/>for<sp/>reversed<sp/>ordered<sp/>arrays.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Int<sp/>i<sp/>=<sp/>(nr-1)/2;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>middle<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>sf<sp/>=<sp/>data;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>first<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>sl<sp/>=<sp/>data+nr-1;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>last<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(data[i]<sp/>&lt;<sp/>*sf)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swap<sp/>(data[i],<sp/>*sf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(*sl<sp/>&lt;<sp/>*sf)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swap<sp/>(*sl,<sp/>*sf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(data[i]<sp/>&lt;<sp/>*sl)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swap<sp/>(data[i],<sp/>*sl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>par<sp/>=<sp/>*sl;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>partition<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Now<sp/>partition<sp/>until<sp/>the<sp/>pointers<sp/>cross.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(;;)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(*++sf<sp/>&lt;<sp/>par)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(*--sl<sp/>&gt;<sp/>par)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(sf<sp/>&gt;=<sp/>sl)<sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swap<sp/>(*sf,<sp/>*sl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>swap<sp/>(*sf,<sp/>data[nr-1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>sf-data;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(multiThread)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>limit<sp/>threads<sp/>to<sp/>what<sp/>the<sp/>code<sp/>can<sp/>do<sp/>to<sp/>not<sp/>span<sp/>unnecessary</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>workers<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>nthreads<sp/>=<sp/>std::min(2,<sp/>omp_get_max_threads());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>TODO<sp/>parallel<sp/>for<sp/>only<sp/>uses<sp/>2<sp/>threads<sp/>of<sp/>the<sp/>group,<sp/>should<sp/>use<sp/>tasks</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>only<sp/>parallelize<sp/>when<sp/>work<sp/>time<sp/>~<sp/>barrier<sp/>spin<sp/>time<sp/>(3ms)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>otherwise<sp/>oversubscription<sp/>kills<sp/>performance<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>omp<sp/>parallel<sp/>for<sp/>num_threads(nthreads)<sp/>if<sp/>(nr<sp/>&gt;<sp/>500000)</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>thr=0;<sp/>thr&lt;2;<sp/>++thr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(thr==0)<sp/>quickSortAsc<sp/>(data,<sp/>i,<sp/>False,<sp/>rec_lim<sp/>-<sp/>1);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>sort<sp/>left<sp/>part</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(thr==1)<sp/>quickSortAsc<sp/>(sf+1,<sp/>nr-i-1,<sp/>False,<sp/>rec_lim<sp/>-<sp/>1);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>sort<sp/>right<sp/>part</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>quickSortAsc<sp/>(data,<sp/>i,<sp/>False,<sp/>rec_lim<sp/>-<sp/>1);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>sort<sp/>left<sp/>part</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>quickSortAsc<sp/>(sf+1,<sp/>nr-i-1,<sp/>False,<sp/>rec_lim<sp/>-<sp/>1);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>sort<sp/>right<sp/>part</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Find<sp/>the<sp/>k-th<sp/>largest<sp/>element<sp/>using<sp/>a<sp/>partial<sp/>quicksort.</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">T<sp/>GenSort&lt;T&gt;::kthLargest<sp/>(T*<sp/>data,<sp/>uInt<sp/>nr,<sp/>uInt<sp/>k)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(k<sp/>&gt;=<sp/>nr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>throw<sp/>(AipsError<sp/>(&quot;kthLargest(data,<sp/>nr,<sp/>k):<sp/>k<sp/>must<sp/>be<sp/>&lt;<sp/>nr&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Int<sp/>st<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Int<sp/>end<sp/>=<sp/>Int(nr)<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Partition<sp/>until<sp/>a<sp/>set<sp/>of<sp/>1<sp/>or<sp/>2<sp/>elements<sp/>is<sp/>left.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(end<sp/>&gt;<sp/>st+1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Choose<sp/>a<sp/>partition<sp/>element<sp/>by<sp/>taking<sp/>the<sp/>median<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>first,<sp/>middle<sp/>and<sp/>last<sp/>element.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Store<sp/>the<sp/>partition<sp/>element<sp/>at<sp/>the<sp/>end.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Do<sp/>not<sp/>use<sp/>Sedgewick\&apos;s<sp/>advise<sp/>to<sp/>store<sp/>the<sp/>partition<sp/>element<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>data[nr-2].<sp/>This<sp/>has<sp/>dramatic<sp/>results<sp/>for<sp/>reversed<sp/>ordered<sp/>arrays.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Int<sp/>i<sp/>=<sp/>(st+end)/2;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>middle<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>sf<sp/>=<sp/>data+st;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>first<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>sl<sp/>=<sp/>data+end;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>last<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(data[i]<sp/>&lt;<sp/>*sf)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>swap<sp/>(data[i],<sp/>*sf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(*sl<sp/>&lt;<sp/>*sf)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>swap<sp/>(*sl,<sp/>*sf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(data[i]<sp/>&lt;<sp/>*sl)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>swap<sp/>(data[i],<sp/>*sl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>par<sp/>=<sp/>*sl;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>partition<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Now<sp/>partition<sp/>until<sp/>the<sp/>pointers<sp/>cross.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(;;)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(*++sf<sp/>&lt;<sp/>par)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(*--sl<sp/>&gt;<sp/>par)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(sf<sp/>&gt;=<sp/>sl)<sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>swap<sp/>(*sf,<sp/>*sl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swap<sp/>(*sf,<sp/>data[end]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Determine<sp/>index<sp/>of<sp/>partitioning<sp/>and<sp/>update<sp/>the<sp/>start<sp/>and<sp/>end</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>to<sp/>take<sp/>left<sp/>or<sp/>right<sp/>part.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>i<sp/>=<sp/>sf-data;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(i<sp/>&lt;=<sp/>Int(k))<sp/>st<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(i<sp/>&gt;=<sp/>Int(k))<sp/>end<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(end<sp/>==<sp/>st+1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data[st]<sp/>&gt;<sp/>data[end])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swap<sp/>(data[st],<sp/>data[end]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>data[k];</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Do<sp/>an<sp/>insertion<sp/>sort<sp/>in<sp/>ascending<sp/>order.</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">uInt<sp/>GenSort&lt;T&gt;::insSortAsc<sp/>(T*<sp/>data,<sp/>Int<sp/>nr,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>((opt<sp/>&amp;<sp/>Sort::NoDuplicates)<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>insSortAscDup<sp/>(data,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>insSortAscNoDup<sp/>(data,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Do<sp/>an<sp/>insertion<sp/>sort<sp/>in<sp/>ascending<sp/>order.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Keep<sp/>duplicate<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">uInt<sp/>GenSort&lt;T&gt;::insSortAscDup<sp/>(T*<sp/>data,<sp/>Int<sp/>nr)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Int<sp/><sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>cur;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(Int<sp/>i=1;<sp/>i&lt;nr;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>j<sp/><sp/><sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cur<sp/>=<sp/>data[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(j&gt;0<sp/><sp/>&amp;&amp;<sp/><sp/>data[j-1]<sp/>&gt;<sp/>cur)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>data[j]<sp/>=<sp/>data[j-1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>j--;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>data[j]<sp/>=<sp/>cur;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Do<sp/>an<sp/>insertion<sp/>sort<sp/>in<sp/>ascending<sp/>order.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Skip<sp/>duplicate<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">uInt<sp/>GenSort&lt;T&gt;::insSortAscNoDup<sp/>(T*<sp/>data,<sp/>Int<sp/>nr)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nr<sp/>&lt;<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>nr;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>nothing<sp/>to<sp/>sort</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Int<sp/><sp/>j,<sp/>k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>cur;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Int<sp/>n<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(Int<sp/>i=1;<sp/>i&lt;nr;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>j<sp/><sp/><sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cur<sp/>=<sp/>data[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(j&gt;0<sp/><sp/>&amp;&amp;<sp/><sp/>data[j-1]<sp/>&gt;<sp/>cur)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>j--;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(j<sp/>&lt;=<sp/>0<sp/><sp/>||<sp/><sp/>!(data[j-1]<sp/>==<sp/>cur))<sp/>{<sp/><sp/><sp/><sp/>//<sp/>no<sp/>equal<sp/>key</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(k=n-1;<sp/>k&gt;=j;<sp/>k--)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>data[k+1]<sp/>=<sp/>data[k];<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>now<sp/>shift<sp/>to<sp/>right</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>data[j]<sp/>=<sp/>cur;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>insert<sp/>in<sp/>right<sp/>place</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>n++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>n;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Do<sp/>a<sp/>heapsort<sp/>in<sp/>ascending<sp/>order.</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>GenSort&lt;T&gt;::heapSortAsc<sp/>(T*<sp/>data,<sp/>Int<sp/>nr)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Use<sp/>the<sp/>heapsort<sp/>algorithm<sp/>described<sp/>by<sp/>Jon<sp/>Bentley<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>UNIX<sp/>Review,<sp/>August<sp/>1992.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>data--;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Int<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(j=nr/2;<sp/>j&gt;=1;<sp/>j--)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>heapAscSiftDown<sp/>(j,<sp/>nr,<sp/>data);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(j=nr;<sp/>j&gt;=2;<sp/>j--)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swap<sp/>(data[1],<sp/>data[j]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>heapAscSiftDown<sp/>(1,<sp/>j-1,<sp/>data);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>GenSort&lt;T&gt;::heapAscSiftDown<sp/>(Int<sp/>low,<sp/>Int<sp/>up,<sp/>T*<sp/>data)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>sav<sp/>=<sp/>data[low];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Int<sp/>c;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Int<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(i=low;<sp/>(c=2*i)&lt;=up;<sp/>i=c)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(c<sp/>&lt;<sp/>up<sp/><sp/>&amp;&amp;<sp/><sp/>data[c+1]<sp/>&gt;<sp/>data[c])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>c++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>data[i]<sp/>=<sp/>data[c];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>data[i]<sp/>=<sp/>sav;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(<sp/>;<sp/>(c=i/2)&gt;=<sp/>low;<sp/>i=c)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!(data[i]<sp/>&gt;<sp/>data[c]))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swap<sp/>(data[c],<sp/>data[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">uInt<sp/>GenSort&lt;T&gt;::parSort<sp/>(T*<sp/>data,<sp/>uInt<sp/>nr,<sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>nthread)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>nthr<sp/>=<sp/>nthread;<sp/><sp/><sp/><sp/>//<sp/>to<sp/>avoid<sp/>compiler<sp/>warning</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nthread<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nthr<sp/>=<sp/>nthread;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Do<sp/>not<sp/>use<sp/>more<sp/>threads<sp/>than<sp/>there<sp/>are<sp/>values.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(uInt(nthr)<sp/>&gt;<sp/>nr)<sp/>nthr<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nthr<sp/>=<sp/>omp_get_max_threads();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(uInt(nthr)<sp/>&gt;<sp/>nr)<sp/>nthr<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nthr<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nthr<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>nthr<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Block&lt;uInt&gt;<sp/>index(nr+1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Block&lt;uInt&gt;<sp/>tinx(nthr+1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Block&lt;uInt&gt;<sp/>np(nthr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Determine<sp/>ordered<sp/>parts<sp/>in<sp/>the<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>It<sp/>is<sp/>done<sp/>in<sp/>parallel,<sp/>whereafter<sp/>the<sp/>parts<sp/>are<sp/>combined.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>step<sp/>=<sp/>nr/nthr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;nthr;<sp/>++i)<sp/>tinx[i]<sp/>=<sp/>i*step;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tinx[nthr]<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>omp<sp/>parallel<sp/>for<sp/>num_threads(nthr)</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;nthr;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>nparts<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>index[tinx[i]]<sp/>=<sp/>tinx[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(uInt<sp/>j=tinx[i]+1;<sp/>j&lt;tinx[i+1];<sp/>++j)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data[j-1]<sp/>&gt;<sp/>data[j])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index[tinx[i]+nparts]<sp/>=<sp/>j;<sp/><sp/><sp/><sp/>//<sp/>out<sp/>of<sp/>order,<sp/>thus<sp/>new<sp/>part</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nparts++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>np[i]<sp/>=<sp/>nparts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Make<sp/>index<sp/>parts<sp/>consecutive<sp/>by<sp/>shifting<sp/>to<sp/>the<sp/>left.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>See<sp/>if<sp/>last<sp/>and<sp/>next<sp/>part<sp/>can<sp/>be<sp/>combined.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>uInt<sp/>nparts<sp/>=<sp/>np[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i=1;<sp/>i&lt;nthr;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(data[tinx[i]-1]<sp/>&gt;<sp/>data[tinx[i]])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>index[nparts++]<sp/>=<sp/>index[tinx[i]];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nparts<sp/>==<sp/>tinx[i]+1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>nparts<sp/>+=<sp/>np[i]-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(uInt<sp/>j=1;<sp/>j&lt;np[i];<sp/>++j)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>index[nparts++]<sp/>=<sp/>index[tinx[i]+j];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>index[nparts]<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//cout&lt;&lt;&quot;nparts=&quot;&lt;&lt;nparts&lt;&lt;endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Merge<sp/>the<sp/>array<sp/>parts.<sp/>Each<sp/>part<sp/>is<sp/>ordered.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nparts<sp/>&lt;<sp/>nr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Block&lt;T&gt;<sp/>tmp(nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>res<sp/>=<sp/>merge<sp/>(data,<sp/>tmp.storage(),<sp/>nr,<sp/>index.storage(),<sp/>nparts);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Skip<sp/>duplicates<sp/>if<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>((opt<sp/>&amp;<sp/>Sort::NoDuplicates)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>nr<sp/>=<sp/>insSortAscNoDup<sp/>(res,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Result<sp/>is<sp/>in<sp/>ascending<sp/>order;<sp/>reverse<sp/>if<sp/>descending<sp/>is<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ord<sp/>==<sp/>Sort::Descending)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>reverse<sp/>(data,<sp/>res,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>(res<sp/>!=<sp/>data)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>The<sp/>final<sp/>result<sp/>must<sp/>end<sp/>up<sp/>in<sp/>data.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>objcopy<sp/>(data,<sp/>res,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Each<sp/>part<sp/>has<sp/>length<sp/>1,<sp/>so<sp/>the<sp/>array<sp/>is<sp/>in<sp/>descending<sp/>order<sp/>and<sp/>unique.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Reverse<sp/>if<sp/>ascending<sp/>is<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ord<sp/>==<sp/>Sort::Ascending)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>reverse<sp/>(data,<sp/>data,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal">}<sp/><sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>GenSort&lt;T&gt;::reverse<sp/>(T*<sp/>data,<sp/>const<sp/>T*<sp/>res,<sp/>uInt<sp/>nr)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>result<sp/>must<sp/>end<sp/>up<sp/>in<sp/>data.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(res<sp/>==<sp/>data)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(uInt<sp/>i=0;<sp/>i&lt;nr/2;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>tmp(data[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>data[i]<sp/>=<sp/>data[nr-1-i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>data[nr-i-1]<sp/>=<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(uInt<sp/>i=0;<sp/>i&lt;nr;<sp/>++i)<sp/>data[i]<sp/>=<sp/>res[nr-1-i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">T*<sp/>GenSort&lt;T&gt;::merge<sp/>(T*<sp/>data,<sp/>T*<sp/>tmp,<sp/>uInt<sp/>nr,<sp/>uInt*<sp/>index,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uInt<sp/>nparts)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>a<sp/>=<sp/>data;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>b<sp/>=<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>np<sp/>=<sp/>nparts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>If<sp/>the<sp/>nr<sp/>of<sp/>parts<sp/>is<sp/>odd,<sp/>the<sp/>last<sp/>part<sp/>is<sp/>not<sp/>merged.<sp/>To<sp/>avoid<sp/>having</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>to<sp/>copy<sp/>it<sp/>to<sp/>the<sp/>other<sp/>array,<sp/>a<sp/>pointer<sp/>&apos;last&apos;<sp/>is<sp/>kept.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Note<sp/>that<sp/>merging<sp/>the<sp/>previous<sp/>part<sp/>with<sp/>the<sp/>last<sp/>part<sp/>works<sp/>fine,<sp/>even</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>if<sp/>the<sp/>last<sp/>part<sp/>is<sp/>in<sp/>the<sp/>same<sp/>buffer.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>last<sp/>=<sp/>data<sp/>+<sp/>index[np-1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(np<sp/>&gt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>omp<sp/>parallel<sp/>for<sp/>schedule(dynamic)</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;np;<sp/>i+=2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>&lt;<sp/>np-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Merge<sp/>2<sp/>subsequent<sp/>parts<sp/>of<sp/>the<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>f1<sp/>=<sp/>a+index[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>f2<sp/>=<sp/>a+index[i+1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>to<sp/>=<sp/>b+index[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>uInt<sp/>na<sp/>=<sp/>index[i+1]-index[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>uInt<sp/>nb<sp/>=<sp/>index[i+2]-index[i+1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>np-2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//cout&lt;&lt;&quot;swap<sp/>last<sp/>np=&quot;<sp/>&lt;&lt;np&lt;&lt;endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>f2<sp/>=<sp/>last;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>last<sp/>=<sp/>to;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>uInt<sp/>ia=0,<sp/>ib=0,<sp/>k=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(ia<sp/>&lt;<sp/>na<sp/>&amp;&amp;<sp/>ib<sp/>&lt;<sp/>nb)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(f1[ia]<sp/>&lt;<sp/>f2[ib])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>to[k]<sp/>=<sp/>f1[ia++];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>to[k]<sp/>=<sp/>f2[ib++];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>k++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ia<sp/>&lt;<sp/>na)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(uInt<sp/>p=ia;<sp/>p&lt;na;<sp/>p++,k++)<sp/>to[k]<sp/>=<sp/>f1[p];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(uInt<sp/>p=ib;<sp/>p&lt;nb;<sp/>p++,k++)<sp/>to[k]<sp/>=<sp/>f2[p];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Collapse<sp/>the<sp/>index.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>k=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;np;<sp/>i+=2)<sp/>index[k++]<sp/>=<sp/>index[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>index[k]<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>np<sp/>=<sp/>k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Swap<sp/>the<sp/>index<sp/>target<sp/>and<sp/>destination.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>c<sp/>=<sp/>a;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>a<sp/>=<sp/>b;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>b<sp/>=<sp/>c;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>a;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">uInt<sp/>GenSort&lt;T&gt;::insSort<sp/>(T*<sp/>data,<sp/>uInt<sp/>nr,<sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>uInt<sp/>n<sp/>=<sp/>insSortAsc<sp/>(data,<sp/>nr,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ord<sp/>==<sp/>Sort::Descending)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reverse<sp/>(data,<sp/>data,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>n;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">uInt<sp/>GenSort&lt;T&gt;::quickSort<sp/>(T*<sp/>data,<sp/>uInt<sp/>nr,<sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Use<sp/>quicksort<sp/>to<sp/>do<sp/>rough<sp/>sorting.<sp/>expected<sp/>recursion<sp/>limit<sp/>log2(nr)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>uInt<sp/>unr<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Int<sp/>rec_limit<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(unr<sp/>&gt;&gt;=<sp/>1)<sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rec_limit++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rec_limit<sp/>*=<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>quickSortAsc<sp/>(data,<sp/>nr,<sp/>True,<sp/>rec_limit);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Finish<sp/>with<sp/>an<sp/>insertion<sp/>sort<sp/>(which<sp/>also<sp/>skips<sp/>duplicates<sp/>if<sp/>needed).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Note:<sp/>if<sp/>quicksort<sp/>keeps<sp/>track<sp/>of<sp/>its<sp/>boundaries,<sp/>the<sp/>insSort<sp/>of<sp/>all</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>parts<sp/>could<sp/>be<sp/>done<sp/>in<sp/>parallel.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>insSort<sp/>(data,<sp/>nr,<sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">uInt<sp/>GenSort&lt;T&gt;::heapSort<sp/>(T*<sp/>data,<sp/>uInt<sp/>nr,<sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>uInt<sp/>n<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>heapSortAsc<sp/>(data,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>((opt<sp/>&amp;<sp/>Sort::NoDuplicates)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n<sp/>=<sp/>insSortAscNoDup<sp/>(data,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ord<sp/>==<sp/>Sort::Descending)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reverse<sp/>(data,<sp/>data,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>n;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">uInt<sp/>GenSort&lt;T&gt;::sort<sp/>(T*<sp/>data,<sp/>uInt<sp/>nr,<sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Determine<sp/>the<sp/>default<sp/>sort<sp/>to<sp/>use.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(opt<sp/>-<sp/>(opt&amp;Sort::NoDuplicates)<sp/>==<sp/>Sort::DefaultSort)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>nthr<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nthr<sp/>=<sp/>omp_get_max_threads();</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>type<sp/>=<sp/>(nr&lt;1000<sp/>||<sp/>nthr==1<sp/><sp/>?<sp/><sp/>Sort::QuickSort<sp/>:<sp/>Sort::ParSort);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>opt<sp/>=<sp/>opt<sp/>-<sp/>Sort::DefaultSort<sp/>+<sp/>type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Do<sp/>the<sp/>sort.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>((opt<sp/>&amp;<sp/>Sort::HeapSort)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>heapSort<sp/>(data,<sp/>nr,<sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>if<sp/>((opt<sp/>&amp;<sp/>Sort::InsSort)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>insSort<sp/>(data,<sp/>nr,<sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>if<sp/>((opt<sp/>&amp;<sp/>Sort::QuickSort)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>quickSort<sp/>(data,<sp/>nr,<sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>parSort<sp/>(data,<sp/>nr,<sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">uInt<sp/>GenSort&lt;T&gt;::sort<sp/>(Array&lt;T&gt;&amp;<sp/>data,<sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Bool<sp/>del;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>dptr<sp/>=<sp/>data.getStorage(del);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>uInt<sp/>nr<sp/>=<sp/>sort<sp/>(dptr,<sp/>data.nelements(),<sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>data.putStorage<sp/>(dptr,<sp/>del);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">uInt<sp/>GenSort&lt;T&gt;::sort<sp/>(Block&lt;T&gt;&amp;<sp/>data,<sp/>uInt<sp/>nr,<sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>sort<sp/>(data.storage(),<sp/>std::min&lt;uInt&gt;(nr,<sp/>data.nelements()),<sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">INX<sp/>GenSortIndirect&lt;T,INX&gt;::sort<sp/>(Vector&lt;INX&gt;&amp;<sp/>indexVector,<sp/>const<sp/>Array&lt;T&gt;&amp;<sp/>data,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Bool<sp/>del;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>T*<sp/>dptr<sp/>=<sp/>data.getStorage(del);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX<sp/>nr<sp/>=<sp/>sort<sp/>(indexVector,<sp/>dptr,<sp/>data.nelements(),<sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>data.freeStorage<sp/>(dptr,<sp/>del);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">INX<sp/>GenSortIndirect&lt;T,INX&gt;::sort<sp/>(Vector&lt;INX&gt;&amp;<sp/>indexVector,<sp/>const<sp/>Block&lt;T&gt;&amp;<sp/>data,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INX<sp/>nr,<sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>sort<sp/>(indexVector,<sp/>data.storage(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::min(nr,<sp/>static_cast&lt;INX&gt;(data.nelements())),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Use<sp/>quicksort<sp/>if<sp/>nothing<sp/>given.</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">INX<sp/>GenSortIndirect&lt;T,INX&gt;::sort<sp/>(Vector&lt;INX&gt;&amp;<sp/>indexVector,<sp/>const<sp/>T*<sp/>data,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INX<sp/>nr,<sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Fill<sp/>the<sp/>index<sp/>vector<sp/>with<sp/>the<sp/>indices.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>indexVector.resize<sp/>(nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>indgen<sp/>(indexVector);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Pass<sp/>the<sp/>sort<sp/>function<sp/>a<sp/>C-array<sp/>of<sp/>indices,<sp/>because<sp/>indexing</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>in<sp/>there<sp/>is<sp/>(much)<sp/>faster<sp/>than<sp/>in<sp/>a<sp/>vector.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Bool<sp/>del;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX*<sp/>inx<sp/>=<sp/>indexVector.getStorage<sp/>(del);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Choose<sp/>the<sp/>sort<sp/>required.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Determine<sp/>the<sp/>default<sp/>sort<sp/>to<sp/>use.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(opt<sp/>-<sp/>(opt&amp;Sort::NoDuplicates)<sp/>==<sp/>Sort::DefaultSort)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>nthr<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nthr<sp/>=<sp/>omp_get_max_threads();</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>type<sp/>=<sp/>(nr&lt;1000<sp/>||<sp/>nthr==1<sp/><sp/>?<sp/><sp/>Sort::QuickSort<sp/>:<sp/>Sort::ParSort);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>opt<sp/>=<sp/>opt<sp/>-<sp/>Sort::DefaultSort<sp/>+<sp/>type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Do<sp/>the<sp/>sort.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>((opt<sp/>&amp;<sp/>Sort::HeapSort)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>heapSort<sp/>(inx,<sp/>data,<sp/>nr,<sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>((opt<sp/>&amp;<sp/>Sort::InsSort)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>insSort<sp/>(inx,<sp/>data,<sp/>nr,<sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>((opt<sp/>&amp;<sp/>Sort::QuickSort)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>quickSort<sp/>(inx,<sp/>data,<sp/>nr,<sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>parSort<sp/>(inx,<sp/>data,<sp/>nr,<sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>indexVector.putStorage<sp/>(inx,<sp/>del);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>If<sp/>n<sp/>&lt;<sp/>nr,<sp/>some<sp/>duplicates<sp/>have<sp/>been<sp/>deleted.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>This<sp/>means<sp/>we<sp/>have<sp/>to<sp/>resize<sp/>the<sp/>Vector.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&lt;<sp/>nr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vector&lt;INX&gt;<sp/>vec(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vec<sp/>=<sp/>indexVector<sp/>(Slice(0,n));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indexVector.reference<sp/>(vec);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>n;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">INX<sp/>GenSortIndirect&lt;T,INX&gt;::insSort<sp/>(INX*<sp/>inx,<sp/>const<sp/>T*<sp/>data,<sp/>INX<sp/>nr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX<sp/>n<sp/>=<sp/>insSortAsc<sp/>(inx,<sp/>data,<sp/>nr,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ord<sp/>==<sp/>Sort::Descending)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GenSort&lt;INX&gt;::reverse<sp/>(inx,<sp/>inx,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>n;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">INX<sp/>GenSortIndirect&lt;T,INX&gt;::quickSort<sp/>(INX*<sp/>inx,<sp/>const<sp/>T*<sp/>data,<sp/>INX<sp/>nr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Use<sp/>quicksort<sp/>to<sp/>do<sp/>rough<sp/>sorting.<sp/>expected<sp/>recursion<sp/>limit<sp/>log2(nr)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX<sp/>unr<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Int<sp/>rec_limit<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(unr<sp/>&gt;&gt;=<sp/>1)<sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rec_limit++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rec_limit<sp/>*=<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>quickSortAsc<sp/>(inx,<sp/>data,<sp/>nr,<sp/>True,<sp/>rec_limit);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Finish<sp/>with<sp/>an<sp/>insertion<sp/>sort<sp/>(which<sp/>also<sp/>skips<sp/>duplicates<sp/>if<sp/>needed).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Note:<sp/>if<sp/>quicksort<sp/>keeps<sp/>track<sp/>of<sp/>its<sp/>boundaries,<sp/>the<sp/>insSort<sp/>of<sp/>all</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>parts<sp/>could<sp/>be<sp/>done<sp/>in<sp/>parallel.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>insSort<sp/>(inx,<sp/>data,<sp/>nr,<sp/>ord,<sp/>opt);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">INX<sp/>GenSortIndirect&lt;T,INX&gt;::heapSort<sp/>(INX*<sp/>inx,<sp/>const<sp/>T*<sp/>data,<sp/>INX<sp/>nr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX<sp/>n<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>heapSortAsc<sp/>(inx,<sp/>data,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>((opt<sp/>&amp;<sp/>Sort::NoDuplicates)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n<sp/>=<sp/>insSortAscNoDup<sp/>(inx,<sp/>data,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ord<sp/>==<sp/>Sort::Descending)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GenSort&lt;INX&gt;::reverse<sp/>(inx,<sp/>inx,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>n;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">INX<sp/>GenSortIndirect&lt;T,INX&gt;::parSort<sp/>(INX*<sp/>inx,<sp/>const<sp/>T*<sp/>data,<sp/>INX<sp/>nr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Sort::Order<sp/>ord,<sp/>int<sp/>opt,<sp/>int<sp/>nthread)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>nthr<sp/>=<sp/>nthread;<sp/><sp/><sp/><sp/>//<sp/>to<sp/>avoid<sp/>compiler<sp/>warning</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nthread<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nthr<sp/>=<sp/>nthread;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Do<sp/>not<sp/>use<sp/>more<sp/>threads<sp/>than<sp/>there<sp/>are<sp/>values.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(INX(nthr)<sp/>&gt;<sp/>nr)<sp/>nthr<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nthr<sp/>=<sp/>omp_get_max_threads();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(INX(nthr)<sp/>&gt;<sp/>nr)<sp/>nthr<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nthr<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nthr<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>nthr<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Block&lt;INX&gt;<sp/>index(nr+1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Block&lt;INX&gt;<sp/>tinx(nthr+1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Block&lt;INX&gt;<sp/>np(nthr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Determine<sp/>ordered<sp/>parts<sp/>in<sp/>the<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>It<sp/>is<sp/>done<sp/>in<sp/>parallel,<sp/>whereafter<sp/>the<sp/>parts<sp/>are<sp/>combined.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>step<sp/>=<sp/>nr/nthr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;nthr;<sp/>++i)<sp/>tinx[i]<sp/>=<sp/>i*step;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tinx[nthr]<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>omp<sp/>parallel<sp/>for<sp/>num_threads(nthr)</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;nthr;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>nparts<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>index[tinx[i]]<sp/>=<sp/>tinx[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(INX<sp/>j=tinx[i]+1;<sp/>j&lt;tinx[i+1];<sp/>++j)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data[inx[j-1]]<sp/>&gt;<sp/>data[inx[j]])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index[tinx[i]+nparts]<sp/>=<sp/>j;<sp/><sp/><sp/><sp/>//<sp/>out<sp/>of<sp/>order,<sp/>thus<sp/>new<sp/>part</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nparts++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>np[i]<sp/>=<sp/>nparts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Make<sp/>index<sp/>parts<sp/>consecutive<sp/>by<sp/>shifting<sp/>to<sp/>the<sp/>left.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>See<sp/>if<sp/>last<sp/>and<sp/>next<sp/>part<sp/>can<sp/>be<sp/>combined.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX<sp/>nparts<sp/>=<sp/>np[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i=1;<sp/>i&lt;nthr;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(data[tinx[i]-1]<sp/>&gt;<sp/>data[tinx[i]])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>index[nparts++]<sp/>=<sp/>index[tinx[i]];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nparts<sp/>==<sp/>tinx[i]+1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>nparts<sp/>+=<sp/>np[i]-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(INX<sp/>j=1;<sp/>j&lt;np[i];<sp/>++j)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>index[nparts++]<sp/>=<sp/>index[tinx[i]+j];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>index[nparts]<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//cout&lt;&lt;&quot;nparts=&quot;&lt;&lt;nparts&lt;&lt;endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Merge<sp/>the<sp/>array<sp/>parts.<sp/>Each<sp/>part<sp/>is<sp/>ordered.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nparts<sp/>&lt;<sp/>nr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Block&lt;INX&gt;<sp/>inxtmp(nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX*<sp/>res<sp/>=<sp/>merge<sp/>(data,<sp/>inx,<sp/>inxtmp.storage(),<sp/>nr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index.storage(),<sp/>nparts);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Skip<sp/>duplicates<sp/>if<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>((opt<sp/>&amp;<sp/>Sort::NoDuplicates)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>nr<sp/>=<sp/>insSortAscNoDup<sp/>(res,<sp/>data,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Result<sp/>is<sp/>in<sp/>ascending<sp/>order;<sp/>reverse<sp/>if<sp/>descending<sp/>is<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ord<sp/>==<sp/>Sort::Descending)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>GenSort&lt;INX&gt;::reverse<sp/>(inx,<sp/>res,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>(res<sp/>!=<sp/>inx)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>The<sp/>final<sp/>result<sp/>must<sp/>end<sp/>up<sp/>in<sp/>inx.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>objcopy<sp/>(inx,<sp/>res,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Each<sp/>part<sp/>has<sp/>length<sp/>1,<sp/>so<sp/>the<sp/>array<sp/>is<sp/>in<sp/>reversed<sp/>order<sp/>and<sp/>unique.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Reverse<sp/>if<sp/>ascending<sp/>is<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ord<sp/>==<sp/>Sort::Ascending)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>GenSort&lt;INX&gt;::reverse<sp/>(inx,<sp/>inx,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal">}<sp/><sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">INX*<sp/>GenSortIndirect&lt;T,INX&gt;::merge<sp/>(const<sp/>T*<sp/>data,<sp/>INX*<sp/>inx,<sp/>INX*<sp/>tmp,<sp/>INX<sp/>nr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INX*<sp/>index,<sp/>INX<sp/>nparts)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX*<sp/>a<sp/>=<sp/>inx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX*<sp/>b<sp/>=<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>np<sp/>=<sp/>nparts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>If<sp/>the<sp/>nr<sp/>of<sp/>parts<sp/>is<sp/>odd,<sp/>the<sp/>last<sp/>part<sp/>is<sp/>not<sp/>merged.<sp/>To<sp/>avoid<sp/>having</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>to<sp/>copy<sp/>it<sp/>to<sp/>the<sp/>other<sp/>array,<sp/>a<sp/>pointer<sp/>&apos;last&apos;<sp/>is<sp/>kept.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Note<sp/>that<sp/>merging<sp/>the<sp/>previous<sp/>part<sp/>with<sp/>the<sp/>last<sp/>part<sp/>works<sp/>fine,<sp/>even</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>if<sp/>the<sp/>last<sp/>part<sp/>is<sp/>in<sp/>the<sp/>same<sp/>buffer.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX*<sp/>last<sp/>=<sp/>inx<sp/>+<sp/>index[np-1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(np<sp/>&gt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>omp<sp/>parallel<sp/>for<sp/>schedule(dynamic)</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;np;<sp/>i+=2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>&lt;<sp/>np-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Merge<sp/>2<sp/>subsequent<sp/>parts<sp/>of<sp/>the<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX*<sp/>f1<sp/>=<sp/>a+index[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX*<sp/>f2<sp/>=<sp/>a+index[i+1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX*<sp/>to<sp/>=<sp/>b+index[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX<sp/>na<sp/>=<sp/>index[i+1]-index[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX<sp/>nb<sp/>=<sp/>index[i+2]-index[i+1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>np-2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//cout&lt;&lt;&quot;swap<sp/>last<sp/>np=&quot;<sp/>&lt;&lt;np&lt;&lt;endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>f2<sp/>=<sp/>last;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>last<sp/>=<sp/>to;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX<sp/>ia=0,<sp/>ib=0,<sp/>k=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(ia<sp/>&lt;<sp/>na<sp/>&amp;&amp;<sp/>ib<sp/>&lt;<sp/>nb)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(data[f1[ia]]<sp/>&lt;=<sp/>data[f2[ib]])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>to[k]<sp/>=<sp/>f1[ia++];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>to[k]<sp/>=<sp/>f2[ib++];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>k++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ia<sp/>&lt;<sp/>na)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(INX<sp/>p=ia;<sp/>p&lt;na;<sp/>p++,k++)<sp/>to[k]<sp/>=<sp/>f1[p];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(INX<sp/>p=ib;<sp/>p&lt;nb;<sp/>p++,k++)<sp/>to[k]<sp/>=<sp/>f2[p];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Collapse<sp/>the<sp/>index.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>k=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;np;<sp/>i+=2)<sp/>index[k++]<sp/>=<sp/>index[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>index[k]<sp/>=<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>np<sp/>=<sp/>k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Swap<sp/>the<sp/>index<sp/>target<sp/>and<sp/>destination.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX*<sp/>c<sp/>=<sp/>a;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>a<sp/>=<sp/>b;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>b<sp/>=<sp/>c;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>a;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>GenSortIndirect&lt;T,INX&gt;::quickSortAsc<sp/>(INX*<sp/>inx,<sp/>const<sp/>T*<sp/>data,<sp/>INX<sp/>nr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bool<sp/>multiThread,<sp/>Int<sp/>rec_lim)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nr<sp/>&lt;=<sp/>32)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>finish<sp/>it<sp/>off<sp/>with<sp/>insertion<sp/>sort</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>not<sp/>enough<sp/>progress,<sp/>abort<sp/>into<sp/>runtime<sp/>limited<sp/>heapsort</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(rec_lim<sp/>&lt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>heapSortAsc(inx,<sp/>data,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX*<sp/>mid=<sp/>inx<sp/>+<sp/>(nr-1)/2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX*<sp/>sf<sp/>=<sp/>inx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX*<sp/>sl<sp/>=<sp/>inx+nr-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(isAscending<sp/>(data,<sp/>*sf,<sp/>*mid))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swapInx<sp/>(*sf,<sp/>*mid);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(isAscending<sp/>(data,<sp/>*sf,<sp/>*sl))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swapInx<sp/>(*sf,<sp/>*sl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(isAscending<sp/>(data,<sp/>*sl,<sp/>*mid))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swapInx<sp/>(*sl,<sp/>*mid);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>partVal<sp/>=<sp/>data[*sl];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX<sp/>partInx<sp/>=<sp/>*sl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Compare<sp/>indices<sp/>in<sp/>case<sp/>the<sp/>keys<sp/>are<sp/>equal.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>This<sp/>ensures<sp/>that<sp/>the<sp/>sort<sp/>is<sp/>stable.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sf++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sl--;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(;;)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(data[*sf]<sp/>&lt;<sp/>partVal</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/><sp/>(partVal<sp/>==<sp/>data[*sf]<sp/><sp/>&amp;&amp;<sp/><sp/>*sf<sp/>&lt;<sp/>partInx))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sf++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(data[*sl]<sp/>&gt;<sp/>partVal</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/><sp/>(partVal<sp/>==<sp/>data[*sl]<sp/><sp/>&amp;&amp;<sp/><sp/>*sl<sp/>&gt;<sp/>partInx))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sl--;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(sf<sp/>&gt;=<sp/>sl)<sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swapInx<sp/>(*sf,<sp/>*sl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>swapInx<sp/>(*sf,<sp/>inx[nr-1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX<sp/>n<sp/>=<sp/>sf-inx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(multiThread)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>limit<sp/>threads<sp/>to<sp/>what<sp/>the<sp/>code<sp/>can<sp/>do<sp/>to<sp/>not<sp/>span<sp/>unnecessary</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>workers<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_OPENMP</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>nthreads<sp/>=<sp/>std::min(2,<sp/>omp_get_max_threads());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>TODO<sp/>parallel<sp/>for<sp/>only<sp/>uses<sp/>2<sp/>threads<sp/>of<sp/>the<sp/>group,<sp/>should<sp/>use<sp/>tasks</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>only<sp/>parallelize<sp/>when<sp/>work<sp/>time<sp/>~<sp/>barrier<sp/>spin<sp/>time<sp/>(3ms)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>otherwise<sp/>oversubscription<sp/>kills<sp/>performance<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>omp<sp/>parallel<sp/>for<sp/>num_threads(nthreads)<sp/>if<sp/>(nr<sp/>&gt;<sp/>500000)</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>thr=0;<sp/>thr&lt;2;<sp/>++thr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(thr==0)<sp/>quickSortAsc<sp/>(inx,<sp/>data,<sp/>n,<sp/>False,<sp/>rec_lim<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(thr==1)<sp/>quickSortAsc<sp/>(sf+1,<sp/>data,<sp/>nr-n-1,<sp/>False,<sp/>rec_lim<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>quickSortAsc<sp/>(inx,<sp/>data,<sp/>n,<sp/>False,<sp/>rec_lim<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>quickSortAsc<sp/>(sf+1,<sp/>data,<sp/>nr-n-1,<sp/>False,<sp/>rec_lim<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Find<sp/>the<sp/>k-th<sp/>largest<sp/>element<sp/>using<sp/>a<sp/>partial<sp/>quicksort.</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">INX<sp/>GenSortIndirect&lt;T,INX&gt;::kthLargest<sp/>(T*<sp/>data,<sp/>INX<sp/>nr,<sp/>INX<sp/>k)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(k<sp/>&gt;=<sp/>nr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>throw<sp/>(AipsError<sp/>(&quot;kthLargest(data,<sp/>nr,<sp/>k):<sp/>k<sp/>must<sp/>be<sp/>&lt;<sp/>nr&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Create<sp/>and<sp/>fill<sp/>an<sp/>index<sp/>vector.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vector&lt;INX&gt;<sp/>indexVector(nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>indgen(indexVector);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX*<sp/>inx<sp/>=<sp/>indexVector.data();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX<sp/>st<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX<sp/>end<sp/>=<sp/>INX(nr)<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Partition<sp/>until<sp/>a<sp/>set<sp/>of<sp/>1<sp/>or<sp/>2<sp/>elements<sp/>is<sp/>left.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(end<sp/>&gt;<sp/>st+1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Choose<sp/>a<sp/>partition<sp/>element<sp/>by<sp/>taking<sp/>the<sp/>median<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>first,<sp/>middle<sp/>and<sp/>last<sp/>element.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Store<sp/>the<sp/>partition<sp/>element<sp/>at<sp/>the<sp/>end.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Do<sp/>not<sp/>use<sp/>Sedgewick\&apos;s<sp/>advise<sp/>to<sp/>store<sp/>the<sp/>partition<sp/>element<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>data[nr-2].<sp/>This<sp/>has<sp/>dramatic<sp/>results<sp/>for<sp/>reversed<sp/>ordered<sp/>arrays.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX<sp/>i<sp/>=<sp/>(st+end)/2;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>middle<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX*<sp/>sf<sp/>=<sp/>inx+st;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>first<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX*<sp/>sl<sp/>=<sp/>inx+end;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>last<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(data[inx[i]]<sp/>&lt;<sp/>data[*sf])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>swapInx<sp/>(inx[i],<sp/>*sf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(data[*sl]<sp/>&lt;<sp/>data[*sf])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>swapInx<sp/>(*sl,<sp/>*sf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(data[inx[i]]<sp/>&lt;<sp/>data[*sl])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>swapInx<sp/>(inx[i],<sp/>*sl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>partVal<sp/>=<sp/>data[*sl];<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>partition<sp/>element</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Now<sp/>partition<sp/>until<sp/>the<sp/>pointers<sp/>cross.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(;;)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(data[*++sf]<sp/>&lt;<sp/>partVal)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(data[*--sl]<sp/>&gt;<sp/>partVal)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(sf<sp/>&gt;=<sp/>sl)<sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>swapInx<sp/>(*sf,<sp/>*sl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swapInx<sp/>(*sf,<sp/>inx[end]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Determine<sp/>index<sp/>of<sp/>partitioning<sp/>and<sp/>update<sp/>the<sp/>start<sp/>and<sp/>end</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>to<sp/>take<sp/>left<sp/>or<sp/>right<sp/>part.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>i<sp/>=<sp/>sf-inx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(i<sp/>&lt;=<sp/>INX(k))<sp/>st<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(i<sp/>&gt;=<sp/>INX(k))<sp/>end<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(end<sp/>==<sp/>st+1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data[inx[st]]<sp/>&gt;<sp/>data[inx[end]])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swapInx<sp/>(inx[st],<sp/>inx[end]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>inx[k];</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Do<sp/>an<sp/>insertion<sp/>sort<sp/>in<sp/>ascending<sp/>order.</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">INX<sp/>GenSortIndirect&lt;T,INX&gt;::insSortAsc<sp/>(INX*<sp/>inx,<sp/>const<sp/>T*<sp/>data,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>INX<sp/>nr,<sp/>int<sp/>opt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>((opt<sp/>&amp;<sp/>Sort::NoDuplicates)<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>insSortAscDup<sp/>(inx,<sp/>data,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}else{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>insSortAscNoDup<sp/>(inx,<sp/>data,<sp/>nr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Do<sp/>an<sp/>insertion<sp/>sort<sp/>in<sp/>ascending<sp/>order.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Keep<sp/>duplicate<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">INX<sp/>GenSortIndirect&lt;T,INX&gt;::insSortAscDup<sp/>(INX*<sp/>inx,<sp/>const<sp/>T*<sp/>data,<sp/>INX<sp/>nr)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(INX<sp/>i=1;<sp/>i&lt;nr;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Int64<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX<sp/>cur<sp/>=<sp/>inx[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(j&gt;0<sp/><sp/>&amp;&amp;<sp/><sp/>isAscending<sp/>(data,<sp/>inx[j-1],<sp/>cur))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>inx[j]<sp/>=<sp/>inx[j-1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>j--;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>inx[j]<sp/>=<sp/>cur;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Do<sp/>an<sp/>insertion<sp/>sort<sp/>in<sp/>ascending<sp/>order.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Skip<sp/>duplicate<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">INX<sp/>GenSortIndirect&lt;T,INX&gt;::insSortAscNoDup<sp/>(INX*<sp/>inx,<sp/>const<sp/>T*<sp/>data,<sp/>INX<sp/>nr)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nr<sp/>&lt;<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>nr;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>nothing<sp/>to<sp/>sort</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX<sp/>n<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(INX<sp/>i=1;<sp/>i&lt;nr;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Int64<sp/>j<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INX<sp/>cur<sp/>=<sp/>inx[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(j&gt;0<sp/><sp/>&amp;&amp;<sp/><sp/>data[inx[j-1]]<sp/>&gt;<sp/>data[cur])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>j--;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(j<sp/>&lt;=<sp/>0<sp/><sp/>||<sp/><sp/>!(data[inx[j-1]]<sp/>==<sp/>data[cur]))<sp/>{<sp/><sp/><sp/>//<sp/>no<sp/>equal<sp/>key</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(Int64<sp/>k=n-1;<sp/>k&gt;=j;<sp/>k--)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inx[k+1]<sp/>=<sp/>inx[k];<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>now<sp/>shift<sp/>to<sp/>right</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>inx[j]<sp/>=<sp/>cur;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>insert<sp/>in<sp/>right<sp/>place</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>n++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>n;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Do<sp/>a<sp/>heapsort<sp/>in<sp/>ascending<sp/>order.</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>GenSortIndirect&lt;T,INX&gt;::heapSortAsc<sp/>(INX*<sp/>inx,<sp/>const<sp/>T*<sp/>data,<sp/>INX<sp/>nr)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Use<sp/>the<sp/>heapsort<sp/>algorithm<sp/>described<sp/>by<sp/>Jon<sp/>Bentley<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>UNIX<sp/>Review,<sp/>August<sp/>1992.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inx--;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(j=nr/2;<sp/>j&gt;=1;<sp/>j--)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>heapAscSiftDown<sp/>(inx,<sp/>j,<sp/>nr,<sp/>data);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(j=nr;<sp/>j&gt;=2;<sp/>j--)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swapInx<sp/>(inx[1],<sp/>inx[j]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>heapAscSiftDown<sp/>(inx,<sp/>1,<sp/>j-1,<sp/>data);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T,<sp/>class<sp/>INX&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>GenSortIndirect&lt;T,INX&gt;::heapAscSiftDown<sp/>(INX*<sp/>inx,<sp/>INX<sp/>low,<sp/>INX<sp/>up,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>T*<sp/>data)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX<sp/>sav<sp/>=<sp/>inx[low];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX<sp/>c;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INX<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(i=low;<sp/>(c=2*i)&lt;=up;<sp/>i=c)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(c<sp/>&lt;<sp/>up<sp/><sp/>&amp;&amp;<sp/><sp/>isAscending<sp/>(data,<sp/>inx[c+1],<sp/>inx[c]))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>c++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>inx[i]<sp/>=<sp/>inx[c];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inx[i]<sp/>=<sp/>sav;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(<sp/>;<sp/>(c=i/2)&gt;=<sp/>low;<sp/>i=c)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(isAscending<sp/>(data,<sp/>inx[c],<sp/>inx[i]))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>swapInx<sp/>(inx[c],<sp/>inx[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">}<sp/>//#<sp/>NAMESPACE<sp/>CASACORE<sp/>-<sp/>END</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
    </programlisting>
    <location file="casa/Utilities/GenSort.tcc"/>
  </compounddef>
</doxygen>
