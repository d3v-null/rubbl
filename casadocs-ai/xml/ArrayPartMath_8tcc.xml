<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="ArrayPartMath_8tcc" kind="file" language="C++">
    <compoundname>ArrayPartMath.tcc</compoundname>
    <includedby refid="ArrayPartMath_8h" local="yes">casa/Arrays/ArrayPartMath.h</includedby>
    <invincdepgraph>
      <node id="13">
        <label>tables/TaQL/ExprMathNodeArray.cc</label>
        <link refid="ExprMathNodeArray_8cc"/>
      </node>
      <node id="9">
        <label>tables/TaQL/ExprLogicNodeArray.cc</label>
        <link refid="ExprLogicNodeArray_8cc"/>
      </node>
      <node id="2">
        <label>casa/Arrays/ArrayPartMath.h</label>
        <link refid="ArrayPartMath_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
      </node>
      <node id="4">
        <label>casa/Arrays.h</label>
        <link refid="Arrays_8h"/>
      </node>
      <node id="8">
        <label>tables/TaQL/ExprGroupAggrFuncArray.cc</label>
        <link refid="ExprGroupAggrFuncArray_8cc"/>
      </node>
      <node id="10">
        <label>tables/TaQL/ExprNodeArray.cc</label>
        <link refid="ExprNodeArray_8cc"/>
      </node>
      <node id="1">
        <label>casa/Arrays/ArrayPartMath.tcc</label>
        <link refid="ArrayPartMath_8tcc"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="12">
        <label>tables/TaQL/MArrayMath.h</label>
        <link refid="MArrayMath_8h"/>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
      </node>
      <node id="6">
        <label>tables/TaQL/ExprFuncNode.cc</label>
        <link refid="ExprFuncNode_8cc"/>
      </node>
      <node id="3">
        <label>casa/Arrays/ArrayPartMath.cc</label>
        <link refid="ArrayPartMath_8cc"/>
      </node>
      <node id="7">
        <label>tables/TaQL/ExprFuncNodeArray.cc</label>
        <link refid="ExprFuncNodeArray_8cc"/>
      </node>
      <node id="11">
        <label>tables/TaQL/ExprNodeRep.cc</label>
        <link refid="ExprNodeRep_8cc"/>
      </node>
      <node id="5">
        <label>tables/TaQL/MArrayLogical.h</label>
        <link refid="MArrayLogical_8h"/>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
      </node>
    </invincdepgraph>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">//#<sp/>ArrayMath.cc:<sp/>Arithmetic<sp/>functions<sp/>defined<sp/>on<sp/>Arrays</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Copyright<sp/>(C)<sp/>1993,1994,1995,1996,1997,1998,1999,2001,2003</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Associated<sp/>Universities,<sp/>Inc.<sp/>Washington<sp/>DC,<sp/>USA.</highlight></codeline>
<codeline><highlight class="normal">//#</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>This<sp/>library<sp/>is<sp/>free<sp/>software;<sp/>you<sp/>can<sp/>redistribute<sp/>it<sp/>and/or<sp/>modify<sp/>it</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>under<sp/>the<sp/>terms<sp/>of<sp/>the<sp/>GNU<sp/>Library<sp/>General<sp/>Public<sp/>License<sp/>as<sp/>published<sp/>by</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>the<sp/>Free<sp/>Software<sp/>Foundation;<sp/>either<sp/>version<sp/>2<sp/>of<sp/>the<sp/>License,<sp/>or<sp/>(at<sp/>your</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>option)<sp/>any<sp/>later<sp/>version.</highlight></codeline>
<codeline><highlight class="normal">//#</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>This<sp/>library<sp/>is<sp/>distributed<sp/>in<sp/>the<sp/>hope<sp/>that<sp/>it<sp/>will<sp/>be<sp/>useful,<sp/>but<sp/>WITHOUT</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>ANY<sp/>WARRANTY;<sp/>without<sp/>even<sp/>the<sp/>implied<sp/>warranty<sp/>of<sp/>MERCHANTABILITY<sp/>or</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE.<sp/><sp/>See<sp/>the<sp/>GNU<sp/>Library<sp/>General<sp/>Public</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>License<sp/>for<sp/>more<sp/>details.</highlight></codeline>
<codeline><highlight class="normal">//#</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>You<sp/>should<sp/>have<sp/>received<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>GNU<sp/>Library<sp/>General<sp/>Public<sp/>License</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>along<sp/>with<sp/>this<sp/>library;<sp/>if<sp/>not,<sp/>write<sp/>to<sp/>the<sp/>Free<sp/>Software<sp/>Foundation,</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Inc.,<sp/>675<sp/>Massachusetts<sp/>Ave,<sp/>Cambridge,<sp/>MA<sp/>02139,<sp/>USA.</highlight></codeline>
<codeline><highlight class="normal">//#</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Correspondence<sp/>concerning<sp/>AIPS++<sp/>should<sp/>be<sp/>addressed<sp/>as<sp/>follows:</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Internet<sp/>email:<sp/>casa-feedback@nrao.edu.</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Postal<sp/>address:<sp/>AIPS++<sp/>Project<sp/>Office</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>National<sp/>Radio<sp/>Astronomy<sp/>Observatory</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>520<sp/>Edgemont<sp/>Road</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Charlottesville,<sp/>VA<sp/>22903-2475<sp/>USA</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;ArrayPartMath.h&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;ArrayIter.h&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;ArrayError.h&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cassert&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;complex&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">namespace<sp/>casacore<sp/>{<sp/>//#<sp/>NAMESPACE<sp/>CASACORE<sp/>-<sp/>BEGIN</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialSums<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(collapseAxes.nelements()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>array.copy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndim<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Array&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resShape,<sp/>incr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>nelemCont<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>stax<sp/>=<sp/>partialFuncHelper<sp/>(nelemCont,<sp/>resShape,<sp/>incr,<sp/>shape,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteData,<sp/>deleteRes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>arrData<sp/>=<sp/>array.getStorage<sp/>(deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>data<sp/>=<sp/>arrData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Find<sp/>out<sp/>how<sp/>contiguous<sp/>the<sp/>data<sp/>is,<sp/>i.e.<sp/>if<sp/>some<sp/>contiguous<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>end<sp/>up<sp/>in<sp/>the<sp/>same<sp/>output<sp/>element.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>cont<sp/>tells<sp/>if<sp/>any<sp/>data<sp/>are<sp/>contiguous.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>stax<sp/>gives<sp/>the<sp/>first<sp/>non-contiguous<sp/>axis.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>n0<sp/>gives<sp/>the<sp/>number<sp/>of<sp/>contiguous<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>cont<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>n0<sp/>=<sp/>nelemCont;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>incr0<sp/>=<sp/>incr(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nelemCont<sp/>&lt;=<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cont<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n0<sp/>=<sp/>shape(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stax<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(cont)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>tmp<sp/>=<sp/>*res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp<sp/>+=<sp/>*data++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*res<sp/>=<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*res<sp/>+=<sp/>*data++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>+=<sp/>incr0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=stax;<sp/>ax&lt;ndim;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>+=<sp/>incr(ax);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>shape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>array.freeStorage<sp/>(arrData,<sp/>deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialSumSqrs<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(collapseAxes.nelements()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>array.copy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndim<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Array&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resShape,<sp/>incr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>nelemCont<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>stax<sp/>=<sp/>partialFuncHelper<sp/>(nelemCont,<sp/>resShape,<sp/>incr,<sp/>shape,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteData,<sp/>deleteRes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>arrData<sp/>=<sp/>array.getStorage<sp/>(deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>data<sp/>=<sp/>arrData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Find<sp/>out<sp/>how<sp/>contiguous<sp/>the<sp/>data<sp/>is,<sp/>i.e.<sp/>if<sp/>some<sp/>contiguous<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>end<sp/>up<sp/>in<sp/>the<sp/>same<sp/>output<sp/>element.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>cont<sp/>tells<sp/>if<sp/>any<sp/>data<sp/>are<sp/>contiguous.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>stax<sp/>gives<sp/>the<sp/>first<sp/>non-contiguous<sp/>axis.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>n0<sp/>gives<sp/>the<sp/>number<sp/>of<sp/>contiguous<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>cont<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>n0<sp/>=<sp/>nelemCont;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>incr0<sp/>=<sp/>incr(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nelemCont<sp/>&lt;=<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cont<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n0<sp/>=<sp/>shape(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stax<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(cont)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>tmp<sp/>=<sp/>*res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp<sp/>+=<sp/>*data<sp/>*<sp/>*data;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*res<sp/>=<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*res<sp/>+=<sp/>*data<sp/>*<sp/>*data;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>+=<sp/>incr0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=stax;<sp/>ax&lt;ndim;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>+=<sp/>incr(ax);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>shape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>array.freeStorage<sp/>(arrData,<sp/>deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialProducts<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(collapseAxes.nelements()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>array.copy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndim<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Array&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resShape,<sp/>incr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>nelemCont<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>stax<sp/>=<sp/>partialFuncHelper<sp/>(nelemCont,<sp/>resShape,<sp/>incr,<sp/>shape,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result<sp/>=<sp/>T(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteData,<sp/>deleteRes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>arrData<sp/>=<sp/>array.getStorage<sp/>(deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>data<sp/>=<sp/>arrData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Find<sp/>out<sp/>how<sp/>contiguous<sp/>the<sp/>data<sp/>is,<sp/>i.e.<sp/>if<sp/>some<sp/>contiguous<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>end<sp/>up<sp/>in<sp/>the<sp/>same<sp/>output<sp/>element.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>cont<sp/>tells<sp/>if<sp/>any<sp/>data<sp/>are<sp/>contiguous.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>stax<sp/>gives<sp/>the<sp/>first<sp/>non-contiguous<sp/>axis.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>n0<sp/>gives<sp/>the<sp/>number<sp/>of<sp/>contiguous<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>cont<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>n0<sp/>=<sp/>nelemCont;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>incr0<sp/>=<sp/>incr(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nelemCont<sp/>&lt;=<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cont<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n0<sp/>=<sp/>shape(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stax<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(cont)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>tmp<sp/>=<sp/>*res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp<sp/>*=<sp/>*data++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*res<sp/>=<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*res<sp/>*=<sp/>*data++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>+=<sp/>incr0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=stax;<sp/>ax&lt;ndim;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>+=<sp/>incr(ax);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>shape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>array.freeStorage<sp/>(arrData,<sp/>deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialMins<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(collapseAxes.nelements()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>array.copy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndim<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Array&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resShape,<sp/>incr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>nelemCont<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>stax<sp/>=<sp/>partialFuncHelper<sp/>(nelemCont,<sp/>resShape,<sp/>incr,<sp/>shape,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteData,<sp/>deleteRes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>arrData<sp/>=<sp/>array.getStorage<sp/>(deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>data<sp/>=<sp/>arrData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Initialize<sp/>the<sp/>minima<sp/>with<sp/>the<sp/>first<sp/>value<sp/>of<sp/>collapsed<sp/>axes.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>end(shape-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;collapseAxes.nelements();<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>axis<sp/>=<sp/>collapseAxes(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>end(axis)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>tmp(array);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>to<sp/>get<sp/>a<sp/>non-const<sp/>array<sp/>for<sp/>operator()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>scratch(result);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.assign_conforming(<sp/>tmp(IPosition(ndim,0),<sp/>end).reform<sp/>(resShape)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Find<sp/>out<sp/>how<sp/>contiguous<sp/>the<sp/>data<sp/>is,<sp/>i.e.<sp/>if<sp/>some<sp/>contiguous<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>end<sp/>up<sp/>in<sp/>the<sp/>same<sp/>output<sp/>element.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>cont<sp/>tells<sp/>if<sp/>any<sp/>data<sp/>are<sp/>contiguous.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>stax<sp/>gives<sp/>the<sp/>first<sp/>non-contiguous<sp/>axis.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>n0<sp/>gives<sp/>the<sp/>number<sp/>of<sp/>contiguous<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>cont<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>n0<sp/>=<sp/>nelemCont;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>incr0<sp/>=<sp/>incr(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nelemCont<sp/>&lt;=<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cont<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n0<sp/>=<sp/>shape(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stax<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(cont)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>tmp<sp/>=<sp/>*res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(*data<sp/>&lt;<sp/>tmp)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>*data;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>data++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*res<sp/>=<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(*data<sp/>&lt;<sp/>*res)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*res<sp/>=<sp/>*data;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>data++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>+=<sp/>incr0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=stax;<sp/>ax&lt;ndim;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>+=<sp/>incr(ax);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>shape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>array.freeStorage<sp/>(arrData,<sp/>deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialMaxs<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(collapseAxes.nelements()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>array.copy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndim<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Array&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resShape,<sp/>incr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>nelemCont<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>stax<sp/>=<sp/>partialFuncHelper<sp/>(nelemCont,<sp/>resShape,<sp/>incr,<sp/>shape,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteData,<sp/>deleteRes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>arrData<sp/>=<sp/>array.getStorage<sp/>(deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>data<sp/>=<sp/>arrData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Initialize<sp/>the<sp/>maxima<sp/>with<sp/>the<sp/>first<sp/>value<sp/>of<sp/>collapsed<sp/>axes.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>end(shape-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;collapseAxes.nelements();<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>axis<sp/>=<sp/>collapseAxes(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>end(axis)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>tmp(array);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>to<sp/>get<sp/>a<sp/>non-const<sp/>array<sp/>for<sp/>operator()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.assign_conforming(<sp/>tmp(IPosition(ndim,0),<sp/>end).reform<sp/>(resShape)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Find<sp/>out<sp/>how<sp/>contiguous<sp/>the<sp/>data<sp/>is,<sp/>i.e.<sp/>if<sp/>some<sp/>contiguous<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>end<sp/>up<sp/>in<sp/>the<sp/>same<sp/>output<sp/>element.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>cont<sp/>tells<sp/>if<sp/>any<sp/>data<sp/>are<sp/>contiguous.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>stax<sp/>gives<sp/>the<sp/>first<sp/>non-contiguous<sp/>axis.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>n0<sp/>gives<sp/>the<sp/>number<sp/>of<sp/>contiguous<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>cont<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>n0<sp/>=<sp/>nelemCont;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>incr0<sp/>=<sp/>incr(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nelemCont<sp/>&lt;=<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cont<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n0<sp/>=<sp/>shape(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stax<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(cont)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>tmp<sp/>=<sp/>*res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(*data<sp/>&gt;<sp/>tmp)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>*data;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>data++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*res<sp/>=<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(*data<sp/>&gt;<sp/>*res)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*res<sp/>=<sp/>*data;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>data++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>+=<sp/>incr0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=stax;<sp/>ax&lt;ndim;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>+=<sp/>incr(ax);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>shape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>array.freeStorage<sp/>(arrData,<sp/>deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialMeans<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(collapseAxes.nelements()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>array.copy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>=<sp/>partialSums<sp/>(array,<sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>nr<sp/>=<sp/>result.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nr<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>factor<sp/>=<sp/>array.nelements()<sp/>/<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>deleteRes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>res<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;nr;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>res[i]<sp/>/=<sp/>1.0<sp/>*<sp/>factor;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result.putStorage<sp/>(res,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialVariances<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Array&lt;T&gt;&amp;<sp/>means)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>partialVariances<sp/>(array,<sp/>collapseAxes,<sp/>means,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialVariances<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Array&lt;T&gt;&amp;<sp/>means,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_t<sp/>ddof)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndim<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Array&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resShape,<sp/>incr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>nelemCont<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>stax<sp/>=<sp/>partialFuncHelper<sp/>(nelemCont,<sp/>resShape,<sp/>incr,<sp/>shape,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!<sp/>resShape.isEqual<sp/>(means.shape()))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>throw<sp/>ArrayError<sp/>(&quot;partialVariances:<sp/>shape<sp/>of<sp/>means<sp/>array<sp/>mismatches<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;shape<sp/>of<sp/>result<sp/>array&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>nr<sp/>=<sp/>result.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>factor<sp/>=<sp/>int(array.nelements()<sp/>/<sp/>nr)<sp/>-<sp/>ddof;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(factor<sp/>&lt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteData,<sp/>deleteRes,<sp/>deleteMean;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>arrData<sp/>=<sp/>array.getStorage<sp/>(deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>data<sp/>=<sp/>arrData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>meanData<sp/>=<sp/>means.getStorage<sp/>(deleteMean);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>mean<sp/>=<sp/>meanData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Find<sp/>out<sp/>how<sp/>contiguous<sp/>the<sp/>data<sp/>is,<sp/>i.e.<sp/>if<sp/>some<sp/>contiguous<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>end<sp/>up<sp/>in<sp/>the<sp/>same<sp/>output<sp/>element.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>cont<sp/>tells<sp/>if<sp/>any<sp/>data<sp/>are<sp/>contiguous.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>stax<sp/>gives<sp/>the<sp/>first<sp/>non-contiguous<sp/>axis.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>n0<sp/>gives<sp/>the<sp/>number<sp/>of<sp/>contiguous<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>cont<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>n0<sp/>=<sp/>nelemCont;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>incr0<sp/>=<sp/>incr(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nelemCont<sp/>&lt;=<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cont<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n0<sp/>=<sp/>shape(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stax<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(cont)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>tmp<sp/>=<sp/>*res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>tmpm<sp/>=<sp/>*mean;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>var<sp/>=<sp/>*data++<sp/>-<sp/>tmpm;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp<sp/>+=<sp/>var*var;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*res<sp/>=<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>var<sp/>=<sp/>*data++<sp/>-<sp/>*mean;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*res<sp/>+=<sp/>var*var;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>+=<sp/>incr0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mean<sp/>+=<sp/>incr0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=stax;<sp/>ax&lt;ndim;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>+=<sp/>incr(ax);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>mean<sp/>+=<sp/>incr(ax);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>shape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;nr;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res[i]<sp/>/=<sp/>1.0<sp/>*<sp/>factor;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>array.freeStorage<sp/>(arrData,<sp/>deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>means.freeStorage<sp/>(meanData,<sp/>deleteMean);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">Array&lt;std::complex&lt;T&gt;&gt;<sp/>partialVariances<sp/>(const<sp/>Array&lt;std::complex&lt;T&gt;&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes,<sp/>const<sp/>Array&lt;std::complex&lt;T&gt;&gt;&amp;<sp/>means,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ddof)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndim<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Array&lt;std::complex&lt;T&gt;&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resShape,<sp/>incr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>nelemCont<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>stax<sp/>=<sp/>partialFuncHelper<sp/>(nelemCont,<sp/>resShape,<sp/>incr,<sp/>shape,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!<sp/>resShape.isEqual<sp/>(means.shape()))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>throw<sp/>ArrayError<sp/>(&quot;partialVariances:<sp/>shape<sp/>of<sp/>means<sp/>array<sp/>mismatches<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;shape<sp/>of<sp/>result<sp/>array&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;std::complex&lt;T&gt;&gt;<sp/>result<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>nr<sp/>=<sp/>result.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>factor<sp/>=<sp/>int(array.nelements()<sp/>/<sp/>nr)<sp/>-<sp/>ddof;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(factor<sp/>&lt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteData,<sp/>deleteRes,<sp/>deleteMean;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>std::complex&lt;T&gt;*<sp/>arrData<sp/>=<sp/>array.getStorage<sp/>(deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>std::complex&lt;T&gt;*<sp/>data<sp/>=<sp/>arrData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>std::complex&lt;T&gt;*<sp/>meanData<sp/>=<sp/>means.getStorage<sp/>(deleteMean);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>std::complex&lt;T&gt;*<sp/>mean<sp/>=<sp/>meanData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::complex&lt;T&gt;*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::complex&lt;T&gt;*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Find<sp/>out<sp/>how<sp/>contiguous<sp/>the<sp/>data<sp/>is,<sp/>i.e.<sp/>if<sp/>some<sp/>contiguous<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>end<sp/>up<sp/>in<sp/>the<sp/>same<sp/>output<sp/>element.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>cont<sp/>tells<sp/>if<sp/>any<sp/>data<sp/>are<sp/>contiguous.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>stax<sp/>gives<sp/>the<sp/>first<sp/>non-contiguous<sp/>axis.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>n0<sp/>gives<sp/>the<sp/>number<sp/>of<sp/>contiguous<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>cont<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>n0<sp/>=<sp/>nelemCont;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>incr0<sp/>=<sp/>incr(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nelemCont<sp/>&lt;=<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cont<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n0<sp/>=<sp/>shape(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stax<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(cont)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::complex&lt;T&gt;<sp/>tmp<sp/>=<sp/>*res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::complex&lt;T&gt;<sp/>tmpm<sp/>=<sp/>*mean;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::complex&lt;T&gt;<sp/>var<sp/>=<sp/>*data++<sp/>-<sp/>tmpm;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp<sp/>+=<sp/>var.real()*var.real()<sp/>+<sp/>var.imag()*var.imag();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*res<sp/>=<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::complex&lt;T&gt;<sp/>var<sp/>=<sp/>*data++<sp/>-<sp/>*mean;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*res<sp/>+=<sp/>var.real()*var.real()<sp/>+<sp/>var.imag()*var.imag();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>+=<sp/>incr0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mean<sp/>+=<sp/>incr0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=stax;<sp/>ax&lt;ndim;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>+=<sp/>incr(ax);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>mean<sp/>+=<sp/>incr(ax);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>shape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;nr;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res[i]<sp/>/=<sp/>1.0<sp/>*<sp/>factor;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>array.freeStorage<sp/>(arrData,<sp/>deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>means.freeStorage<sp/>(meanData,<sp/>deleteMean);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialAvdevs<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Array&lt;T&gt;&amp;<sp/>means)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndim<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Array&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resShape,<sp/>incr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>nelemCont<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>stax<sp/>=<sp/>partialFuncHelper<sp/>(nelemCont,<sp/>resShape,<sp/>incr,<sp/>shape,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!<sp/>resShape.isEqual<sp/>(means.shape()))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>throw<sp/>ArrayError<sp/>(&quot;partialAvdevs:<sp/>shape<sp/>of<sp/>means<sp/>array<sp/>mismatches<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;shape<sp/>of<sp/>result<sp/>array&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>nr<sp/>=<sp/>result.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>factor<sp/>=<sp/>array.nelements()<sp/>/<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteData,<sp/>deleteRes,<sp/>deleteMean;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>arrData<sp/>=<sp/>array.getStorage<sp/>(deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>data<sp/>=<sp/>arrData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>meanData<sp/>=<sp/>means.getStorage<sp/>(deleteMean);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>mean<sp/>=<sp/>meanData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Find<sp/>out<sp/>how<sp/>contiguous<sp/>the<sp/>data<sp/>is,<sp/>i.e.<sp/>if<sp/>some<sp/>contiguous<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>end<sp/>up<sp/>in<sp/>the<sp/>same<sp/>output<sp/>element.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>cont<sp/>tells<sp/>if<sp/>any<sp/>data<sp/>are<sp/>contiguous.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>stax<sp/>gives<sp/>the<sp/>first<sp/>non-contiguous<sp/>axis.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>n0<sp/>gives<sp/>the<sp/>number<sp/>of<sp/>contiguous<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>cont<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>n0<sp/>=<sp/>nelemCont;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>incr0<sp/>=<sp/>incr(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nelemCont<sp/>&lt;=<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cont<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n0<sp/>=<sp/>shape(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stax<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(cont)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>tmp<sp/>=<sp/>*res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>tmpm<sp/>=<sp/>*mean;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp<sp/>+=<sp/>std::abs(*data++<sp/>-<sp/>tmpm);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*res<sp/>=<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*res<sp/>+=<sp/>std::abs(*data++<sp/>-<sp/>*mean);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>+=<sp/>incr0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mean<sp/>+=<sp/>incr0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=stax;<sp/>ax&lt;ndim;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>+=<sp/>incr(ax);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>mean<sp/>+=<sp/>incr(ax);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>shape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;nr;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res[i]<sp/>/=<sp/>1.0<sp/>*<sp/>factor;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>array.freeStorage<sp/>(arrData,<sp/>deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>means.freeStorage<sp/>(meanData,<sp/>deleteMean);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialRmss<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(collapseAxes.nelements()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>array.copy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndim<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Array&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resShape,<sp/>incr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>nelemCont<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>stax<sp/>=<sp/>partialFuncHelper<sp/>(nelemCont,<sp/>resShape,<sp/>incr,<sp/>shape,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>nr<sp/>=<sp/>result.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>factor<sp/>=<sp/>array.nelements()<sp/>/<sp/>nr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteData,<sp/>deleteRes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>arrData<sp/>=<sp/>array.getStorage<sp/>(deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>data<sp/>=<sp/>arrData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Find<sp/>out<sp/>how<sp/>contiguous<sp/>the<sp/>data<sp/>is,<sp/>i.e.<sp/>if<sp/>some<sp/>contiguous<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>end<sp/>up<sp/>in<sp/>the<sp/>same<sp/>output<sp/>element.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>cont<sp/>tells<sp/>if<sp/>any<sp/>data<sp/>are<sp/>contiguous.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>stax<sp/>gives<sp/>the<sp/>first<sp/>non-contiguous<sp/>axis.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>n0<sp/>gives<sp/>the<sp/>number<sp/>of<sp/>contiguous<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>cont<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>n0<sp/>=<sp/>nelemCont;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>incr0<sp/>=<sp/>incr(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nelemCont<sp/>&lt;=<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cont<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n0<sp/>=<sp/>shape(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stax<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(cont)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>tmp<sp/>=<sp/>*res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp<sp/>+=<sp/>*data<sp/>*<sp/>*data;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>data++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*res<sp/>=<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*res<sp/>+=<sp/>*data<sp/>*<sp/>*data;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>data++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>+=<sp/>incr0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=stax;<sp/>ax&lt;ndim;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>+=<sp/>incr(ax);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>shape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;nr;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res[i]<sp/>=<sp/>T(std::sqrt<sp/>(res[i]<sp/>/<sp/>factor));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>array.freeStorage<sp/>(arrData,<sp/>deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialMedians<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>takeEvenMean,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>inPlace)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Need<sp/>to<sp/>make<sp/>shallow<sp/>copy<sp/>because<sp/>operator()<sp/>is<sp/>non-const.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>arr<sp/>=<sp/>array;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Is<sp/>there<sp/>anything<sp/>to<sp/>collapse?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(collapseAxes.nelements()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(inPlace<sp/><sp/>?<sp/><sp/>array<sp/>:<sp/>array.copy());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndim<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Array&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Get<sp/>the<sp/>remaining<sp/>axes.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>It<sp/>also<sp/>checks<sp/>if<sp/>axes<sp/>are<sp/>specified<sp/>correctly.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resAxes<sp/>=<sp/>IPosition::otherAxes<sp/>(ndim,<sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndimRes<sp/>=<sp/>resAxes.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Create<sp/>the<sp/>result<sp/>shape.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Create<sp/>blc<sp/>and<sp/>trc<sp/>to<sp/>step<sp/>through<sp/>the<sp/>input<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resShape(ndimRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>blc(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>trc(shape-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;ndimRes;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resShape[i]<sp/>=<sp/>shape[resAxes[i]];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>trc[resAxes[i]]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndimRes<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resShape.resize(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resShape[0]<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteRes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;T&gt;<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndimRes,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*res++<sp/>=<sp/>median(arr(blc,trc),<sp/>tmp,<sp/>false,<sp/>takeEvenMean,<sp/>inPlace);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=0;<sp/>ax&lt;ndimRes;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>resShape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>blc[resAxes[ax]]++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>trc[resAxes[ax]]++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>blc[resAxes[ax]]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>trc[resAxes[ax]]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndimRes)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialMadfms<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>takeEvenMean,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>inPlace)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Need<sp/>to<sp/>make<sp/>shallow<sp/>copy<sp/>because<sp/>operator()<sp/>is<sp/>non-const.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>arr<sp/>=<sp/>array;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Is<sp/>there<sp/>anything<sp/>to<sp/>collapse?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(collapseAxes.nelements()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(inPlace<sp/><sp/>?<sp/><sp/>array<sp/>:<sp/>array.copy());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndim<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Array&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Get<sp/>the<sp/>remaining<sp/>axes.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>It<sp/>also<sp/>checks<sp/>if<sp/>axes<sp/>are<sp/>specified<sp/>correctly.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resAxes<sp/>=<sp/>IPosition::otherAxes<sp/>(ndim,<sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndimRes<sp/>=<sp/>resAxes.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Create<sp/>the<sp/>result<sp/>shape.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Create<sp/>blc<sp/>and<sp/>trc<sp/>to<sp/>step<sp/>through<sp/>the<sp/>input<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resShape(ndimRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>blc(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>trc(shape-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;ndimRes;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resShape[i]<sp/>=<sp/>shape[resAxes[i]];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>trc[resAxes[i]]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndimRes<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resShape.resize(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resShape[0]<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteRes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;T&gt;<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndimRes,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*res++<sp/>=<sp/>madfm(arr(blc,trc),<sp/>tmp,<sp/>false,<sp/>takeEvenMean,<sp/>inPlace);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=0;<sp/>ax&lt;ndimRes;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>resShape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blc[resAxes[ax]]++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>trc[resAxes[ax]]++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>blc[resAxes[ax]]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>trc[resAxes[ax]]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndimRes)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialFractiles<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>fraction,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>inPlace)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(fraction<sp/>&lt;<sp/>0<sp/><sp/>||<sp/><sp/>fraction<sp/>&gt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>throw(ArrayError(&quot;::fractile(const<sp/>Array&lt;T&gt;&amp;)<sp/>-<sp/>fraction<sp/>&lt;0<sp/>or<sp/>&gt;1<sp/>&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Need<sp/>to<sp/>make<sp/>shallow<sp/>copy<sp/>because<sp/>operator()<sp/>is<sp/>non-const.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>arr<sp/>=<sp/>array;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Is<sp/>there<sp/>anything<sp/>to<sp/>collapse?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(collapseAxes.nelements()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(inPlace<sp/><sp/>?<sp/><sp/>array<sp/>:<sp/>array.copy());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndim<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Array&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Get<sp/>the<sp/>remaining<sp/>axes.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>It<sp/>also<sp/>checks<sp/>if<sp/>axes<sp/>are<sp/>specified<sp/>correctly.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resAxes<sp/>=<sp/>IPosition::otherAxes<sp/>(ndim,<sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndimRes<sp/>=<sp/>resAxes.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Create<sp/>the<sp/>result<sp/>shape.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Create<sp/>blc<sp/>and<sp/>trc<sp/>to<sp/>step<sp/>through<sp/>the<sp/>input<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resShape(ndimRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>blc(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>trc(shape-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;ndimRes;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resShape[i]<sp/>=<sp/>shape[resAxes[i]];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>trc[resAxes[i]]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndimRes<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resShape.resize(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resShape[0]<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteRes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;T&gt;<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndimRes,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*res++<sp/>=<sp/>fractile(arr(blc,trc),<sp/>tmp,<sp/>fraction,<sp/>false,<sp/>inPlace);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=0;<sp/>ax&lt;ndimRes;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>resShape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>blc[resAxes[ax]]++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>trc[resAxes[ax]]++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>blc[resAxes[ax]]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>trc[resAxes[ax]]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndimRes)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T&gt;<sp/>Array&lt;T&gt;<sp/>partialInterFractileRanges<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>fraction,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>inPlace)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Need<sp/>to<sp/>make<sp/>shallow<sp/>copy<sp/>because<sp/>operator()<sp/>is<sp/>non-const.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>arr<sp/>=<sp/>array;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Is<sp/>there<sp/>anything<sp/>to<sp/>collapse?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(collapseAxes.nelements()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(inPlace<sp/><sp/>?<sp/><sp/>array<sp/>:<sp/>array.copy());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndim<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Array&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Get<sp/>the<sp/>remaining<sp/>axes.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>It<sp/>also<sp/>checks<sp/>if<sp/>axes<sp/>are<sp/>specified<sp/>correctly.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resAxes<sp/>=<sp/>IPosition::otherAxes<sp/>(ndim,<sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndimRes<sp/>=<sp/>resAxes.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Create<sp/>the<sp/>result<sp/>shape.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Create<sp/>blc<sp/>and<sp/>trc<sp/>to<sp/>step<sp/>through<sp/>the<sp/>input<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>resShape(ndimRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>blc(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>trc(shape-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;ndimRes;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resShape[i]<sp/>=<sp/>shape[resAxes[i]];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>trc[resAxes[i]]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(ndimRes<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resShape.resize(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resShape[0]<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteRes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;T&gt;<sp/>tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndimRes,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*res++<sp/>=<sp/>interFractileRange(arr(blc,trc),<sp/>tmp,<sp/>fraction,<sp/>false,<sp/>inPlace);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=0;<sp/>ax&lt;ndimRes;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>resShape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blc[resAxes[ax]]++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>trc[resAxes[ax]]++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>blc[resAxes[ax]]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>trc[resAxes[ax]]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndimRes)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T,<sp/>typename<sp/>RES&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>partialArrayMath<sp/>(Array&lt;RES&gt;&amp;<sp/>res,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Array&lt;T&gt;&amp;<sp/>a,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>collapseAxes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>ArrayFunctorBase&lt;T,RES&gt;&amp;<sp/>funcObj)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ReadOnlyArrayIterator&lt;T&gt;<sp/>aiter(a,<sp/>collapseAxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>shape(a.shape().removeAxes<sp/>(collapseAxes));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res.resize<sp/>(shape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>RES*<sp/>data<sp/>=<sp/>res.data();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(!aiter.pastEnd())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*data++<sp/>=<sp/>funcObj(aiter.array());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>aiter.next();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>typename<sp/>RES&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>boxedArrayMath<sp/>(Array&lt;RES&gt;&amp;<sp/>result,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>boxShape,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>ArrayFunctorBase&lt;T,RES&gt;&amp;<sp/>funcObj)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>fullBoxShape,<sp/>resShape;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fillBoxedShape<sp/>(shape,<sp/>boxShape,<sp/>fullBoxShape,<sp/>resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.resize<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(result.contiguousStorage());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>RES*<sp/>res<sp/>=<sp/>result.data();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>blc(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>trc(fullBoxShape-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*res++<sp/>=<sp/>funcObj<sp/>(array(blc,trc));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=0;<sp/>ax&lt;ndim;<sp/>++ax)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>blc[ax]<sp/>+=<sp/>fullBoxShape[ax];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(blc[ax]<sp/>&lt;<sp/>shape[ax])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>trc[ax]<sp/>+=<sp/>fullBoxShape[ax];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(trc[ax]<sp/>&gt;=<sp/>shape[ax])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>trc[ax]<sp/>=<sp/>shape[ax]-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>blc[ax]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>trc[ax]<sp/>=<sp/>fullBoxShape[ax]-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>typename<sp/>RES&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>slidingArrayMath<sp/>(Array&lt;RES&gt;&amp;<sp/>result,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>halfBoxShape,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>ArrayFunctorBase&lt;T,RES&gt;&amp;<sp/>funcObj,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>fillEdge)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>boxEnd,<sp/>resShape;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>empty<sp/>=<sp/>fillSlidingShape<sp/>(shape,<sp/>halfBoxShape,<sp/>boxEnd,<sp/>resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(fillEdge)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result.resize<sp/>(shape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>=<sp/>RES();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result.resize<sp/>(resShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!empty)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Array&lt;RES&gt;<sp/><sp/>resa<sp/>(result);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(fillEdge)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>IPosition<sp/>boxEnd2<sp/>(boxEnd/2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>resa.reference<sp/>(resa(boxEnd2,<sp/>resShape+boxEnd2-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>Array&lt;RES&gt;::iterator<sp/>iterarr(resa.begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>assemble<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IPosition<sp/>blc(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IPosition<sp/>trc(boxEnd);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IPosition<sp/>pos(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*iterarr<sp/>=<sp/>funcObj<sp/>(array(blc,trc));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>++iterarr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(ax=0;<sp/>ax&lt;ndim;<sp/>++ax)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos[ax]<sp/>&lt;<sp/>resShape[ax])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blc[ax]++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>trc[ax]++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blc[ax]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>trc[ax]<sp/>=<sp/>boxEnd[ax];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">}<sp/>//#<sp/>NAMESPACE<sp/>CASACORE<sp/>-<sp/>END</highlight></codeline>
    </programlisting>
    <location file="casa/Arrays/ArrayPartMath.tcc"/>
  </compounddef>
</doxygen>
