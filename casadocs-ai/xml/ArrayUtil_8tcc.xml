<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="ArrayUtil_8tcc" kind="file" language="C++">
    <compoundname>ArrayUtil.tcc</compoundname>
    <includedby refid="ArrayUtil_8h" local="yes">casa/Arrays/ArrayUtil.h</includedby>
    <invincdepgraph>
      <node id="8">
        <label>tables/DataMan/TSMCubeMMap.cc</label>
        <link refid="TSMCubeMMap_8cc"/>
      </node>
      <node id="2">
        <label>casa/Arrays/ArrayUtil.h</label>
        <link refid="ArrayUtil_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
      </node>
      <node id="11">
        <label>tables/TaQL/MArrayUtil.h</label>
        <link refid="MArrayUtil_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
      </node>
      <node id="6">
        <label>tables/DataMan/TSMCube.cc</label>
        <link refid="TSMCube_8cc"/>
      </node>
      <node id="14">
        <label>tables/TaQL/TableParseTableList.cc</label>
        <link refid="TableParseTableList_8cc"/>
      </node>
      <node id="3">
        <label>casa/Arrays/ArrayUtil2.cc</label>
        <link refid="ArrayUtil2_8cc"/>
      </node>
      <node id="13">
        <label>tables/TaQL/RecordExpr.cc</label>
        <link refid="RecordExpr_8cc"/>
      </node>
      <node id="10">
        <label>tables/Tables/TableProxy.cc</label>
        <link refid="TableProxy_8cc"/>
      </node>
      <node id="4">
        <label>casa/OS/Path.cc</label>
        <link refid="Path_8cc"/>
      </node>
      <node id="12">
        <label>tables/TaQL/ExprFuncNodeArray.cc</label>
        <link refid="ExprFuncNodeArray_8cc"/>
      </node>
      <node id="7">
        <label>tables/DataMan/TSMCubeBuff.cc</label>
        <link refid="TSMCubeBuff_8cc"/>
      </node>
      <node id="9">
        <label>tables/Tables/ReadAsciiTable.cc</label>
        <link refid="ReadAsciiTable_8cc"/>
      </node>
      <node id="1">
        <label>casa/Arrays/ArrayUtil.tcc</label>
        <link refid="ArrayUtil_8tcc"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="15">
        <label>tables/TaQL/TableParseUtil.cc</label>
        <link refid="TableParseUtil_8cc"/>
      </node>
      <node id="5">
        <label>tables/apps/tablefromascii.cc</label>
        <link refid="tablefromascii_8cc"/>
      </node>
    </invincdepgraph>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">//#<sp/>ArrayUtil.cc:<sp/>Utility<sp/>functions<sp/>for<sp/>arrays<sp/>(templated)</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Copyright<sp/>(C)<sp/>1995,2001</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Associated<sp/>Universities,<sp/>Inc.<sp/>Washington<sp/>DC,<sp/>USA.</highlight></codeline>
<codeline><highlight class="normal">//#<sp/></highlight></codeline>
<codeline><highlight class="normal">//#<sp/>This<sp/>library<sp/>is<sp/>free<sp/>software;<sp/>you<sp/>can<sp/>redistribute<sp/>it<sp/>and/or<sp/>modify<sp/>it</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>under<sp/>the<sp/>terms<sp/>of<sp/>the<sp/>GNU<sp/>Library<sp/>General<sp/>Public<sp/>License<sp/>as<sp/>published<sp/>by</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>the<sp/>Free<sp/>Software<sp/>Foundation;<sp/>either<sp/>version<sp/>2<sp/>of<sp/>the<sp/>License,<sp/>or<sp/>(at<sp/>your</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>option)<sp/>any<sp/>later<sp/>version.</highlight></codeline>
<codeline><highlight class="normal">//#<sp/></highlight></codeline>
<codeline><highlight class="normal">//#<sp/>This<sp/>library<sp/>is<sp/>distributed<sp/>in<sp/>the<sp/>hope<sp/>that<sp/>it<sp/>will<sp/>be<sp/>useful,<sp/>but<sp/>WITHOUT</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>ANY<sp/>WARRANTY;<sp/>without<sp/>even<sp/>the<sp/>implied<sp/>warranty<sp/>of<sp/>MERCHANTABILITY<sp/>or</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE.<sp/><sp/>See<sp/>the<sp/>GNU<sp/>Library<sp/>General<sp/>Public</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>License<sp/>for<sp/>more<sp/>details.</highlight></codeline>
<codeline><highlight class="normal">//#<sp/></highlight></codeline>
<codeline><highlight class="normal">//#<sp/>You<sp/>should<sp/>have<sp/>received<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>GNU<sp/>Library<sp/>General<sp/>Public<sp/>License</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>along<sp/>with<sp/>this<sp/>library;<sp/>if<sp/>not,<sp/>write<sp/>to<sp/>the<sp/>Free<sp/>Software<sp/>Foundation,</highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Inc.,<sp/>675<sp/>Massachusetts<sp/>Ave,<sp/>Cambridge,<sp/>MA<sp/>02139,<sp/>USA.</highlight></codeline>
<codeline><highlight class="normal">//#<sp/></highlight></codeline>
<codeline><highlight class="normal">//#<sp/>Correspondence<sp/>concerning<sp/>AIPS++<sp/>should<sp/>be<sp/>addressed<sp/>as<sp/>follows:</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Internet<sp/>email:<sp/>casa-feedback@nrao.edu.</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Postal<sp/>address:<sp/>AIPS++<sp/>Project<sp/>Office</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>National<sp/>Radio<sp/>Astronomy<sp/>Observatory</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>520<sp/>Edgemont<sp/>Road</highlight></codeline>
<codeline><highlight class="normal">//#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Charlottesville,<sp/>VA<sp/>22903-2475<sp/>USA</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>CASA_ARRAYUTIL_2_TCC</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>CASA_ARRAYUTIL_2_TCC</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;ArrayUtil.h&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;ArrayError.h&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;algorithm&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">namespace<sp/>casacore<sp/>{<sp/>//#<sp/>NAMESPACE<sp/>CASACORE<sp/>-<sp/>BEGIN</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">Array&lt;T&gt;<sp/>concatenateArray<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>left,<sp/>const<sp/>Array&lt;T&gt;&amp;<sp/>right)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(left.nelements()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>right.copy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(right.nelements()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>left.copy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IPosition<sp/>shape<sp/>=<sp/>right.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IPosition<sp/>leftShape<sp/>=<sp/>left.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!<sp/>shape.isEqual<sp/>(leftShape,<sp/>ndim-1))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>throw<sp/>(ArrayConformanceError<sp/>(&quot;concatenateArray(left,right)&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>shape(ndim-1)<sp/>+=<sp/>leftShape(ndim-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>(shape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IPosition<sp/>start(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>(start,<sp/>leftShape-1).assign_conforming(<sp/>left<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>start(ndim-1)<sp/>=<sp/>leftShape(ndim-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>(start,<sp/>shape-1).assign_conforming(<sp/>right<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">Array&lt;T&gt;<sp/>reorderArray<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IPosition&amp;<sp/>newAxisOrder,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>alwaysCopy)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>newShape,<sp/>incr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>contAxes<sp/>=<sp/>reorderArrayHelper<sp/>(newShape,<sp/>incr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shape,<sp/>newAxisOrder);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>If<sp/>not<sp/>reordered,<sp/>we<sp/>can<sp/>simply<sp/>return<sp/>the<sp/>array<sp/>(or<sp/>a<sp/>copy<sp/>if<sp/>needed).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>ndim<sp/>=<sp/>shape.nelements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(contAxes<sp/>==<sp/>ndim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(alwaysCopy)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>array.copy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>array;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result(newShape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deleteData,<sp/>deleteRes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>arrData<sp/>=<sp/>array.getStorage<sp/>(deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T*<sp/>data<sp/>=<sp/>arrData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>resData<sp/>=<sp/>result.getStorage<sp/>(deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T*<sp/>res<sp/>=<sp/>resData;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Find<sp/>out<sp/>the<sp/>nr<sp/>of<sp/>contiguous<sp/>elements.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>nrcont<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(contAxes<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>contAxes<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;contAxes;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>nrcont<sp/>*=<sp/>shape(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>incr0<sp/>=<sp/>incr(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>n0<sp/>=<sp/>shape(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Loop<sp/>through<sp/>all<sp/>data<sp/>and<sp/>copy<sp/>as<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IPosition<sp/>pos(ndim,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nrcont<sp/>&gt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::copy_n(data,<sp/>nrcont,<sp/>res);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>data<sp/>+=<sp/>nrcont;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>+=<sp/>nrcont;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;n0;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*res<sp/>=<sp/>*data++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>+=<sp/>incr0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>ax;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(ax=contAxes;<sp/>ax&lt;ndim;<sp/>ax++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>+=<sp/>incr(ax);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(++pos(ax)<sp/>&lt;<sp/>shape(ax))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pos(ax)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ax<sp/>==<sp/>ndim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>array.freeStorage<sp/>(arrData,<sp/>deleteData);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage<sp/>(resData,<sp/>deleteRes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">Array&lt;T&gt;<sp/>reverseArray<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,<sp/>size_t<sp/>axis,<sp/>bool<sp/>alwaysCopy)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(axis<sp/>&gt;=<sp/>shape.size())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>throw<sp/>ArrayError(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::string(__FUNCTION__)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>&quot;:<sp/>axis<sp/>number<sp/>is<sp/>higher<sp/>than<sp/>number<sp/>of<sp/>axes<sp/>in<sp/>the<sp/>array&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>nothingToDo<sp/>=<sp/>shape[axis]<sp/>==<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nothingToDo)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(alwaysCopy)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>array.copy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>array;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>deletein,<sp/>deleteout;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>T<sp/>*indata<sp/>=<sp/>array.getStorage(deletein);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result(shape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>*outdata<sp/>=<sp/>result.getStorage(deleteout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>outerProduct<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>innerProduct<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;shape.size();<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(i&lt;axis)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>innerProduct<sp/>*=<sp/>shape[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>(i&gt;axis)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>outerProduct<sp/>*=<sp/>shape[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>j=0;<sp/>j&lt;outerProduct;<sp/>++j)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>idx<sp/>=<sp/>shape[axis]*innerProduct*j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>k=0;<sp/>k&lt;shape[axis];<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::copy_n<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indata<sp/>+<sp/>idx<sp/>+<sp/>innerProduct*k,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>innerProduct,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outdata<sp/>+<sp/>idx<sp/>+<sp/>innerProduct*(shape[axis]<sp/>-<sp/>k<sp/>-<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>array.freeStorage(indata,<sp/>deletein);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>result.putStorage(outdata,<sp/>deleteout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">Array&lt;T&gt;<sp/>reverseArray<sp/>(const<sp/>Array&lt;T&gt;&amp;<sp/>array,<sp/>const<sp/>IPosition&amp;<sp/>reversedAxes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>alwaysCopy)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IPosition&amp;<sp/>shape<sp/>=<sp/>array.shape();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>nothingToDo<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;reversedAxes.size();<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(reversedAxes[i]<sp/>&gt;=<sp/>int(shape.size()))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>ArrayError(std::string(__FUNCTION__)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>&quot;:<sp/>axis<sp/>number<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>std::to_string(reversedAxes[i])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>&quot;<sp/>is<sp/>higher<sp/>than<sp/>number<sp/>of<sp/>axes<sp/>in<sp/>the<sp/>array&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(shape[reversedAxes[i]]<sp/>&gt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>nothingToDo<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nothingToDo)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(alwaysCopy)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>array.copy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>array;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Array&lt;T&gt;<sp/>result<sp/>=<sp/>array.copy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;reversedAxes.size();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>=<sp/>reverseArray(result,<sp/>reversedAxes[i],<sp/>alwaysCopy);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">}<sp/>//#<sp/>NAMESPACE<sp/>CASACORE<sp/>-<sp/>END</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
    </programlisting>
    <location file="casa/Arrays/ArrayUtil.tcc"/>
  </compounddef>
</doxygen>
